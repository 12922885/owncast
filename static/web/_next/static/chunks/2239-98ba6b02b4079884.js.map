{"version":3,"file":"static/chunks/2239-98ba6b02b4079884.js","mappings":"gQAIAA,EAAQ,OAOD,MAAMC,EAA6B,I,IAAA,QAAEC,EAAO,QAAEC,GAAS,EAC5D,MAAMC,EAAWC,EAAAA,OAAsC,MACjDC,EAAYD,EAAAA,OAAmC,MA6BrD,OA3BAA,EAAAA,WAAgB,KAEd,IAAKC,EAAUC,QAAS,CACtB,MAAMC,EAAeJ,EAASG,QAGxBE,EAAyBH,EAAUC,SAAUG,EAAAA,EAAAA,GAAQF,EAAcN,GAAS,KAChFS,QAAQC,MAAM,mBACPT,GAAWA,EAAQM,EAAQC,EAAAA,MAGpCD,EAAOI,SAASX,EAAQW,UACxBJ,EAAOK,IAAIZ,EAAQa,SAIrBL,EAAAA,EAAAA,IAAAA,IAAAA,cAAgCM,IAC9B,GAAIA,EAAEC,IAAIC,MAAM,QAAS,CACvB,MAAMC,EAAcC,KAAKC,SAASC,SAAS,IAAIC,OAAO,EAAG,GAEzDP,EAAEC,IAAM,GAAsBE,OAAnBH,EAAEC,IAAI,eAAyB,OAAZE,GAGhC,OAAOH,KAER,CAACd,EAASE,KAGX,SAACoB,MAAAA,CAAIC,mBAAe,E,UAElB,SAACC,QAAAA,CACCC,IAAKvB,EACLwB,UAAW,oEAAkF,OAAdC,IAAAA,OAAc,qBCpBrG,MAhBA,MAGEC,QACEC,KAAKC,OAELD,KAAKE,MAAQC,aAAY,MAd7B,WACE,IACEC,MALQ,aAMR,MAAOC,GACPzB,QAAQ0B,MAAMD,IAWZE,KAjBW,KAqBfN,OACEO,cAAcR,KAAKE,SCXvB,MAAMO,EAAgC,CACpCC,SAAU,WACVC,MAAQ,OACRC,OAAS,QAGEC,EAA2C,I,IAAA,IACtD9B,EAAM,GAAE,MACR4B,EAAK,OACLC,EAAM,UACNE,EAAY,OAAM,SAClBC,EAAW,MACZ,EACC,MAAMC,GAAiCC,EAAAA,EAAAA,UACrC,KAAO,CACLC,QAAS,eACTR,SAAU,WACVC,QACAC,YAEF,CAACD,EAAOC,IAGJO,GAAYF,EAAAA,EAAAA,UAChB,IAAM,CACJ,IAAKR,EAAUK,YAAWM,QAAS,EAAGC,WAAY,WAAoB,OAATN,IAC7D,IAAKN,EAAUK,YAAWM,QAAS,EAAGC,WAAY,WAAoB,OAATN,IAC7D,IAAKN,EAAUK,YAAWM,QAAS,KAErC,CAACN,EAAWC,KAGPO,EAAKC,IAAUC,EAAAA,EAAAA,UAAS,IACxBC,EAAMC,IAAWF,EAAAA,EAAAA,UAAS,CAAC,GAAI,KAChCG,EAAU5C,IAAQ0C,EAAK,GAAK1C,EAAM,GAElC6C,EAAY,KAChBL,GAAQD,EAAM,GAAK,GACnBI,EAAQ,CAACD,EAAK,GAAIE,KAGpB,OACE,SAACE,OAAAA,CAAKC,MAAOd,E,SACV,IAAIS,EAAME,GAASI,KAClB,CAACC,EAAWC,IACI,KAAdD,IACE,SAACE,MAAAA,CAECnD,IAAKiD,EACLG,IAAI,GACJL,MAAOX,EAAUc,GACjBG,OAAkB,IAAVH,EAAcL,OAAYS,GAJ7BL,QAanBnB,EAAeyB,aAAe,CAC5BxB,UAAW,OACXC,SAAU,M,wBCtEZ,MAQawB,EAAqC,I,IAC5CrC,GAD4C,OAAEsC,EAAM,WAAEC,EAAY1D,IAAK2D,GAAM,EAEjF,MAAO3D,EAAK4D,IAAUnB,EAAAA,EAAAA,UAASiB,IACxB1B,EAAU6B,IAAepB,EAAAA,EAAAA,UAAS,MAYzC,OAVAqB,EAAAA,EAAAA,YAAU,KACRrC,cAAcN,GACdA,EAAQC,aAAY,KACD,OAAbY,GACF6B,EAAY,MAEdD,EAAO,GAAWG,OAARJ,EAAK,KAAc,OAAXI,KAAKC,UAnBJ,OAqBpB,KAGD,UAACtD,MAAAA,CAAII,UAAWC,IAAAA,O,WACZ0C,IAAU,SAACN,MAAAA,CAAInD,IAAK0D,EAAYN,IAAI,SAErCK,IACC,SAAC3B,EAAcA,CACb9B,IAAKA,EACLgC,SAAUA,EACVD,UAAU,QACVH,MAAM,OACNC,OAAO,a,0BC2PjB,MArQA,MA8DEX,OACEO,cAAcR,KAAKgD,kBACnBhD,KAAKtB,OAAOuE,MAKdC,aAAaC,GACXnD,KAAKoD,YAAcD,EAGrBE,eACE,MAAMC,EAAOtD,KAAKtB,OAAO4E,KAAK,CAAEC,0BAA0B,IAC1DvD,KAAKwD,0BAA4BF,EAEjCA,EAAKG,GAAG,SAASpD,IACA,wBAAXA,EAAEqD,MACJ1D,KAAK2D,gBAAe,GAGP,6BAAXtD,EAAEqD,MAEJ1D,KAAK4D,oCAKa5D,KAAKtB,OAAOmF,aACpBC,iBAAiB,aAAa,KAC1C9D,KAAK4D,oCAITG,gBACEvD,cAAcR,KAAKgE,6BACnBhE,KAAKgE,4BAA8B7D,aAAY,KAC7CH,KAAKiE,2BACJ,KAGLC,cACE1D,cAAcR,KAAKgE,6BAGrBG,kBACEnE,KAAKoE,oBAAoB,GACzBpE,KAAK2D,gBAAe,GAGtBU,0BACErE,KAAK2D,gBAAe,GAGtBW,cACEtE,KAAKoE,oBAAoB,GAG3BA,oBAAoBG,GAClBvE,KAAKwE,QAAUD,EAGjBX,iCAGO5D,KAAKyE,iCAIVzE,KAAK0E,wBAHH1E,KAAKyE,kCAAmC,EAM5Cd,eAAegB,GACb3E,KAAK2E,YAAcA,EAEdA,EAKL3E,KAAK4E,uBAAyBC,YAAW,KACvC7E,KAAKoE,oBAAoB,KACxB,KANDU,aAAa9E,KAAK4E,wBAStBG,yBAAyBC,GACvBhF,KAAKiF,oBAAoBC,KAAKF,GAGhCG,eAAeC,GACbpF,KAAKqF,kBAAkBH,KAAKE,GAG9BE,aAAaC,GACXvF,KAAKwF,gBAAgBN,KAAKK,GAG5BtB,yBACE,MAAMX,EAAOtD,KAAKtB,OAAO4E,KAAK,CAAEC,0BAA0B,IAC1D,IAAKD,IAASA,EAAKmC,IACjB,OAIF,GAAIzF,KAAKtB,OAAOgH,SACd,OAOF,GAAqB,IADA1F,KAAKtB,OAAOiH,eAE/B,OAGF,MAAMC,EAAYtC,EAAKmC,IAAII,gBAC3B7F,KAAKmF,eAAeS,GAEpB,IACE,MAAME,EA3MZ,SAAoCxC,GAClC,MAAMyC,EAAczC,EAAKmC,IAAIO,UAAUC,QACjCC,EAAe5C,EAAK6C,cAC1B,IAAIL,EAIJ,IAAK,IAAIM,EAAI,EAAGC,EAAIN,EAAYO,SAASC,OAAQH,EAAIC,EAAGD,IAEtD,GAAIF,EAAeH,EAAYO,SAASF,GAAGI,IAAK,CAC9CV,EAAUC,EAAYO,SAASF,GAC/B,MAQJ,OAJKN,KACFA,GAAWC,EAAYO,UAGnBR,EAwLaW,CAA2BnD,GAC3C,IAAKwC,IAAYA,EAAQY,eACvB,OAGF,MAAMC,EAAcb,EAAQY,eAAeE,UAErCrB,GADM,IAAIzC,MAAO8D,UAAY5G,KAAKoD,YAClBuD,EAGtB,GAAIpB,EAAU,GAAKA,EAAU,KAvND,GAwN1B,OAGFvF,KAAKsF,aAAaC,GAClB,MAAOsB,GACPjI,QAAQkI,KAAKD,IAIjBE,aACE,GAAwC,IAApC/G,KAAKiF,oBAAoBsB,OAC3B,OAIF,IAAKvG,KAAKtB,QAAUsB,KAAKtB,OAAOgH,SAC9B,OAGF,MAAMsB,EAAahH,KAAKwE,OAExB,IAAIyC,EACJ,GAAIjH,KAAKwD,wBAAyB,CAChC,MAAM0D,EAAUC,GAAOA,EAAIC,QAAO,CAACC,EAAGC,IAAMD,EAAIC,GAAG,GAAKH,EAAIZ,OAEtDgB,EAA0BL,EAAQlH,KAAKiF,qBAAuB,IAC9DuC,EAAiCnI,KAAKoI,MAAgC,IAA1BF,GAAkC,IAE9EG,EAAmBR,EAAQlH,KAAKqF,mBAAqB,IACrDsC,EAA0BtI,KAAKoI,MAAyB,IAAnBC,GAA2B,IAEhEE,EAAiBV,EAAQlH,KAAKwF,iBAAmB,IAGvDyB,EAAO,CACLrB,UAAW+B,EACXpC,QAJ4BlG,KAAKoI,MAAuB,IAAjBG,GAAyB,IAKhEC,iBAAkBL,EAClBhD,OAAQwC,GAAchH,KAAK2E,YAAc,EAAI,GAC7CD,sBAAuB1E,KAAK0E,4BAG9BuC,EAAO,CACLzC,OAAQwC,GAAchH,KAAK2E,YAAc,EAAI,IAIjD3E,KAAKwE,OAAS,EACdxE,KAAK0E,sBAAwB,EAC7B1E,KAAKiF,oBAAsB,GAC3BjF,KAAKqF,kBAAoB,GACzBrF,KAAKwF,gBAAkB,GAEvB,MAAMrH,EAAU,CACd2J,OAAQ,OACRC,QAAS,CACP,eAAgB,oBAElBC,KAAMC,KAAKC,UAAUjB,IAGvB,UACQ7G,MAxRkB,wBAwRUjC,GAClC,MAAOkC,GACPzB,QAAQ0B,MAAMD,IA/PlB8H,YAAYzJ,EAAQC,G,WAClBqB,KAAKtB,OAASA,EACdsB,KAAKwD,yBAA0B,EAC/BxD,KAAKyE,kCAAmC,EACxCzE,KAAKoD,YAAc,EAEnBpD,KAAKiF,oBAAsB,GAC3BjF,KAAKqF,kBAAoB,GACzBrF,KAAKwF,gBAAkB,GACvBxF,KAAKwE,OAAS,EACdxE,KAAK0E,sBAAwB,EAC7B1E,KAAK2E,aAAc,EACnB3E,KAAK4E,uBAAyB,EAC9B5E,KAAKgE,4BAA8B,EAEnChE,KAAKqD,aAAerD,KAAKqD,aAAa+E,KAAKpI,MAC3CA,KAAK+D,cAAgB/D,KAAK+D,cAAcqE,KAAKpI,MAC7CA,KAAKmE,gBAAkBnE,KAAKmE,gBAAgBiE,KAAKpI,MACjDA,KAAKkE,YAAclE,KAAKkE,YAAYkE,KAAKpI,MACzCA,KAAKsE,YAActE,KAAKsE,YAAY8D,KAAKpI,MACzCA,KAAKqI,KAAOrI,KAAKqI,KAAKD,KAAKpI,MAC3BA,KAAKiE,uBAAyBjE,KAAKiE,uBAAuBmE,KAAKpI,MAC/DA,KAAKqE,wBAA0BrE,KAAKqE,wBAAwB+D,KAAKpI,MACjEA,KAAKgD,iBAAmB,EAExBhD,KAAKtB,OAAO+E,GAAG,iBAAkBzD,KAAKqE,yBACtCrE,KAAKtB,OAAO+E,GAAG,QAASzD,KAAKsE,aAC7BtE,KAAKtB,OAAO+E,GAAG,UAAWzD,KAAKmE,iBAC/BnE,KAAKtB,OAAO+E,GAAG,UAAWzD,KAAKmE,iBAC/BnE,KAAKtB,OAAO+E,GAAG,UAAWzD,KAAK+D,eAC/B/D,KAAKtB,OAAO+E,GAAG,QAASzD,KAAKkE,aAG7B,MAAMoE,EAAoB3J,EAAQ4J,IAIlC5J,EAAQ6J,IAAID,IAAM,W,2BAAIE,EAAAA,IAAAA,MAAAA,GAAAA,EAAAA,EAAAA,EAAAA,EAAAA,IAAAA,EAAAA,GAAAA,UAAAA,GACpB,GAAIA,EAAK,GAAGvJ,IAAIC,MAAM,OAAQ,CAC5B,MAAMY,EAAQ,IAAI+C,KAEZ4F,EAAKD,EAAK,GAEhBA,EAAK,GAAK,CAACE,EAASrI,EAAOsI,KACzB,MACMC,GADM,IAAI/F,MACE8D,UAAY7G,EAAM6G,UACpC,EAAK7B,yBAAyB8D,GAC9BH,EAAGC,EAASrI,EAAOsI,IAIvB,OAAON,KAAqBG,IAG9BzI,KAAKqD,eAELrD,KAAKgD,iBAAmB7C,aAAY,KAClCH,KAAKqI,SAnFmB,OC+G9B,MAhHO,SAAuC3J,EAAQC,EAASmK,EAAWC,GACxE,MAAMC,EAAcrK,EAAQsK,aAAa,YACnCC,EAAWvK,EAAQsK,aAAa,YAChCE,EAAkBxK,EAAQsK,aAAa,cAevCG,EAAiB,IAAIF,EAASxK,EAAQ,CAC1C2K,YAAY,IAEdD,EAAeE,aAAa,QAAS,uBACrCF,EAAe3F,GAAG,SAAS,KACzBsF,OAGF,MAAMQ,EAAY,IArBlB,cAA4BP,EAM1BQ,W,IAASC,EAAAA,UAAAA,OAAAA,QAAAA,IAAAA,UAAAA,GAAAA,UAAAA,GAAM,SAAUC,EAAAA,UAAAA,OAAAA,QAAAA,IAAAA,UAAAA,GAAAA,UAAAA,GAAQ,GAAIC,EAAAA,UAAAA,OAAAA,QAAAA,IAAAA,UAAAA,GAAAA,UAAAA,GAAa,GAChD,MAAMC,EAAKC,MAAML,SAASC,EAAKC,EAAOC,GAEtC,OADAC,EAAGE,UAAY,sEACRF,EAPTzB,YAAYd,EAAQlJ,GAClB0L,MAAMxC,EAAGlJ,KAkBuBO,EAAQ,CAC1C2K,YAAY,IAGd,MAAMU,UAAmBZ,EAMvBa,cACE,MAAM1G,EAAO5E,EAAO4E,KAAK,CAAEC,0BAA0B,IAE/C0G,EAAkB,IAAIf,EAASxK,EAAQ,CAC3C2K,YAAY,EACZa,MAAO,SAGHC,EAAQrB,EAAU/G,KAAIqI,IAC1B,MAAMC,EAAc,IAAInB,EAASxK,EAAQ,CACvC2K,YAAY,EACZa,MAAOE,EAAK1G,OAiBd,OAbA2G,EAAY5G,GAAG,SAAS,KAEjBH,GAKLA,EAAKmC,IAAI6E,kBAAkBC,SAAQ,CAACC,EAAKvI,KACvCuI,EAAIC,QAAQxI,IAAUmI,EAAKnI,UAE7BoI,EAAYK,UAAS,IAPnB9L,QAAQkI,KAAK,iDAUVuD,KAGTJ,EAAgBxG,GAAG,SAAS,KAE1BH,EAAKmC,IAAI6E,kBAAkBC,SAAQC,IACjCA,EAAIC,SAAQ,MAEdR,EAAgBS,UAAS,MAG3B,MAAMC,IAA+BrH,KAAUA,EAAKmC,IAGpD,OAAIqD,EAAUvC,OAAS,GAAKoE,EACnB,CAACvB,GAGNN,EAAUvC,OAAS,GAAKoE,EACnB,CAACV,KAAoBE,EAAOZ,EAAWH,GAE3CuB,GAAmD,IAArB7B,EAAUvC,OAItC,CAAC0D,KAAoBE,GAHnB,GAvDXhC,cACE0B,MAAMnL,IA6DV,MAAMkM,EAAa,IAAIb,EAGjBzG,EAAO5E,EAAO4E,KAAK,CAAEC,0BAA0B,IAIrD,OAHAqH,EAAWC,SAAS,wBACpBlM,EAAQmM,kBAAkB,aAAcf,GAEnCzG,EAAKmC,OAINqD,EAAUvC,OAAS,IAAOjD,GAASA,EAAKmC,IAKrCmF,GAREA,GCkYX,MApaA,MA0CE1H,aAAaC,GACXnD,KAAKoD,YAAcD,EAIrB4H,QAIE,IAAI,IAAIjI,MAAO8D,UAAY5G,KAAKgL,YAAYpE,UA3EtB,IA4EpB,OAIF,GAAI5G,KAAKtB,OAAOgH,SACd,OAGF,GAAI1F,KAAKtB,OAAOuM,UACd,OAGF,GAAIjL,KAAKkL,UACP,OAGF,IAAKlL,KAAKyK,QACR,OAGF,MAAMnH,EAAOtD,KAAKtB,OAAO4E,KAAK,CAAEC,0BAA0B,IAK1D,IAAKD,IAASA,EAAKmC,IACjB,OAOF,GAAqB,IADAzF,KAAKtB,OAAOiH,eAE/B,OAGF,IAAIwF,EAAgB,EAEpB,IAGE,GAAuC,IAAnC7H,EAAKmC,IAAI2F,MAAMC,SAAS9E,OAE1B,YADAvG,KAAKsL,UAIPhI,EAAKmC,IAAI2F,MAAMC,SAASd,SAAQgB,IAC9BJ,GAAiBI,EAAO/E,IAAM+E,EAAOxL,SAEvC,MAAOM,GACPzB,QAAQ0B,MAAMD,GAMhB,MACMmL,EADkBlI,EAAKmC,IAAIO,UAAUC,QACM0D,WAAW8B,UAEtDC,EADkBpI,EAAKmC,IAAII,gBACQ2F,EAEzC,IACE,MAAM1F,EAzIZ,SAAoCxC,GAClC,MAAMyC,EAAczC,EAAKmC,IAAIO,UAAUC,QACjCC,EAAe5C,EAAK6C,cAC1B,IAAIL,EAIJ,IAAK,IAAIM,EAAI,EAAGC,EAAIN,EAAYO,SAASC,OAAQH,EAAIC,EAAGD,IAEtD,GAAIF,EAAeH,EAAYO,SAASF,GAAGI,IAAK,CAC9CV,EAAUC,EAAYO,SAASF,GAC/B,MAQJ,OAJKN,KACFA,GAAWC,EAAYO,UAGnBR,EAsHaW,CAA2BnD,GAC3C,IAAKwC,EACH,OAKF,GAAI4F,EA1JuB,KA0JsBP,EAAmC,EAAnBrF,EAAQ/E,SAEvE,YADAf,KAAKsL,UAKP,MAAMK,EAA8BtM,KAAKuM,IA7J3B,IA+JO,IAAnB9F,EAAQ/E,SAhKiC,KAqKrC8K,EAAkB7L,KAAK8L,kBAAkBC,OAAO,CAACJ,IAMjDK,EACJH,EAAgBzE,QAAO,CAAC6E,EAAKzN,IAAYyN,EAAMzN,GAAS,GAAKqN,EAAgBtF,OAG/E,IAAI2F,EAAsB7M,KAAKuM,IACP,IAAtBI,EACA3M,KAAK8M,IAAuB,IAAnBrG,EAAQ/E,SAlLyB,IAG9B,OAqLViL,GAAuBE,IACzBA,EAAsBF,EAAsB,KAG9C,MAAMrF,EAAcb,EAAQY,eAAeE,UAErCrB,GADM,IAAIzC,MAAO8D,UAAY5G,KAAKoD,YAClBuD,EAUtB,GATA3G,KAAKoM,eAAiB7G,EASlBlG,KAAKgN,IAAI9G,GAlMY,IAoMvB,YADAvF,KAAKsL,UAIP,GAAI/F,EAAU2G,EAAqB,CAGjC,GAAIlM,KAAKsM,oBAAsB/G,EAAU2G,EA5MxB,IA4MgE,CAC/E,MAAMK,EAAahH,EAAU,IAA0B,EAAnBO,EAAQ/E,SACtCyL,EAAexM,KAAKtB,OAAOyH,cAAgBoG,EACjD3N,QAAQ6N,KACN,UACAlH,EAAU,IACV,UACAgH,EACA,gBACAvM,KAAKtB,OAAOyH,cACZ,OACAqG,GAIF,MAAME,EAA2BpJ,EAAKmC,IAAI2F,MAAMC,SAAS,GAAG7E,IAE5D,GAAIgG,EAD+BlJ,EAAKmC,IAAI2F,MAAMC,SAAS,GAAGtL,MACd2M,EAG9C,YAFA1M,KAAK2M,KAAKH,GAOd,IAAII,EAAwC,IAAjBlB,EAG3BkB,EAAuBvN,KAAKuM,IAAIvM,KAAK8M,IAAIS,EAlPxB,MAkPiE,GAE9EA,EAAuB5M,KAAK6M,aAnPf,MAsPfD,EAAuB5M,KAAK6M,aAtPb,KA0PjBD,EAAuBvN,KAAKoI,MAA6B,IAAvBmF,GAAkC,IAGpE5M,KAAKD,MAAM6M,QACFrH,GAAWyG,GACpBhM,KAAKC,OAGPrB,QAAQ6N,KACN,UACAlH,EAAU,IACV,MACAyG,EAAsB,IACtB,MACAE,EAAsB,IACtB,gBACAlM,KAAK6M,aACL,WACA7M,KAAKyK,QACL,YACAzK,KAAK8M,QACL,SACA9M,KAAKoD,YACL,oBACApD,KAAK+M,kBAEP,MAAOlG,KAKXyF,mBAGE,GAAItM,KAAK+M,iBAAmB,EAC1B,OAAO,EAKT,OAFY,IAAIjK,MAAO8D,UACH5G,KAAKgN,iBAvRF,IA2RzBL,KAAKH,GACHxM,KAAKiN,2BAA4B,EACjCjN,KAAKkN,0BAA2B,EAEhClN,KAAKgN,iBAAmB,IAAIlK,KAE5BlE,QAAQ6N,KAAK,eAAgBzM,KAAKtB,OAAOyH,cAAe,aAAcqG,GACtExM,KAAKtB,OAAOyH,YAAYqG,GAExB3H,YAAW,KACT7E,KAAKiN,2BAA4B,IAChC,KAGLE,gBAAgBC,GACdpN,KAAK6M,aAAeO,EACpBpN,KAAKtB,OAAOmO,aAAaO,GAG3BrN,Q,IAAMqN,EAAAA,UAAAA,OAAAA,QAAAA,IAAAA,UAAAA,GAAAA,UAAAA,GAAO,GACPpN,KAAKkL,WAAclL,KAAKyK,SAAW2C,IAASpN,KAAK6M,eAIrD7M,KAAK8M,SAAU,EACf9M,KAAKmN,gBAAgBC,IAGvBnN,OACMD,KAAK8M,SACPlO,QAAQyO,IAAI,mCAEdrN,KAAK8M,SAAU,EACf9M,KAAKmN,gBAAgB,GAGvBG,SACEtN,KAAKyK,SAAU,EACfjK,cAAcR,KAAKuN,YACnBzI,aAAa9E,KAAKwN,gBAElBxN,KAAKuN,WAAapN,aAAY,KAC5BH,KAAK+K,UA7UkB,KAkV3B0C,UACEjN,cAAcR,KAAKuN,YACnBzI,aAAa9E,KAAK0N,cAClB1N,KAAKC,OACLD,KAAKyK,SAAU,EAGjBa,UACMtL,KAAKiN,4BAITjN,KAAKkL,WAAY,EACjBlL,KAAKC,OAEL6E,aAAa9E,KAAK0N,cAClB1N,KAAK0N,aAAe7I,YAAW,KAC7B7E,KAAK2N,eApWc,MAwWvBA,aACE7I,aAAa9E,KAAK0N,cAClB1N,KAAKkL,WAAY,EAGnBnH,gBACE,MAAM6J,EAAuB5N,KAAK6N,QAClC7N,KAAK6N,SAAU,EAEf/I,aAAa9E,KAAKwN,gBACbxN,KAAKyK,SAILzK,KAAKsM,qBAULsB,IACH5N,KAAKiN,2BAA4B,EACjCjN,KAAKtB,OAAOoP,YAAYC,iBACxB/N,KAAKgN,iBAAmB,IAAIlK,OAIhCkL,cACEhO,KAAK6N,SAAU,EAGjB3J,cACOlE,KAAKyK,SAIVzK,KAAKyN,UAGPnJ,cACOtE,KAAKyK,SAIVzK,KAAKsL,UAGP2C,sBACEjO,KAAK+M,kBAAoB,EAErB/M,KAAK+M,iBAlagB,EAmavB/M,KAAKyN,WAIPzN,KAAK8L,kBAAkB5G,KAAKlF,KAAKoM,gBAEjCxN,QAAQyO,IACN,iDACArN,KAAK+M,iBACL,sBA5auB,GAibzBlI,YAAW,KACL7E,KAAK+M,iBAAmB,IAC1B/M,KAAK+M,kBAAoB,KA7aE,OAkbjC5I,kBACOnE,KAAKyK,UAAWzK,KAAKkL,YAItBlL,KAAKiN,0BACPjN,KAAKiN,2BAA4B,GAInCjN,KAAKsL,UAELxG,aAAa9E,KAAKwN,gBAClBxN,KAAKwN,eAAiB3I,YAAW,KAC/B7E,KAAKiO,wBArciB,OAuC1B9F,YAAYzJ,GACVsB,KAAKtB,OAASA,EACdsB,KAAK6N,SAAU,EACf7N,KAAKyK,SAAU,EACfzK,KAAK8M,SAAU,EACf9M,KAAKkL,WAAY,EACjBlL,KAAKiN,2BAA4B,EACjCjN,KAAK0N,aAAe,EACpB1N,KAAKuN,WAAa,EAClBvN,KAAK+M,iBAAmB,EACxB/M,KAAKwN,eAAiB,EACtBxN,KAAK6M,aAAe,EACpB7M,KAAKgN,iBAAmB,KACxBhN,KAAKgL,YAAc,IAAIlI,KACvB9C,KAAKoD,YAAc,EACnBpD,KAAKoM,eAAiB,KAItBpM,KAAK8L,kBAAoB,GAEzB9L,KAAKtB,OAAO+E,GAAG,UAAWzD,KAAK+D,cAAcqE,KAAKpI,OAClDA,KAAKtB,OAAO+E,GAAG,QAASzD,KAAKgO,YAAY5F,KAAKpI,OAC9CA,KAAKtB,OAAO+E,GAAG,QAASzD,KAAKsE,YAAY8D,KAAKpI,OAC9CA,KAAKtB,OAAO+E,GAAG,UAAWzD,KAAKmE,gBAAgBiE,KAAKpI,OACpDA,KAAKtB,OAAO+E,GAAG,UAAWzD,KAAKmE,gBAAgBiE,KAAKpI,OACpDA,KAAKtB,OAAO+E,GAAG,QAASzD,KAAKkE,YAAYkE,KAAKpI,OAC9CA,KAAKtB,OAAO+E,GAAG,iBAAkBzD,KAAK+D,cAAcqE,KAAKpI,OACzDA,KAAKtB,OAAO+E,GAAG,UAAWzD,KAAK+D,cAAcqE,KAAKpI,OAElDA,KAAK+K,MAAQ/K,KAAK+K,MAAM3C,KAAKpI,MAC7BA,KAAKD,MAAQC,KAAKD,MAAMqI,KAAKpI,MAC7BA,KAAKsN,OAAStN,KAAKsN,OAAOlF,KAAKpI,MAC/BA,KAAKiO,oBAAsBjO,KAAKiO,oBAAoB7F,KAAKpI,Q,oBCvF7D,MACMkO,EAAgB,iBAChBC,EAA+B,4BAE/B5N,EAAO,IAAI6N,EACjB,IAAIC,EAAkB,KAClBC,EAAqB,KACrBC,GAA4B,EAoBzB,MAAMC,EAAyC,I,IAAA,OACpDC,EAAM,OACNjM,EAAM,eACNkM,GAAiB,GAClB,EACC,MAAMnQ,EAAYD,EAAAA,OAAa,OACxBqQ,EAAcC,IAAmBC,EAAAA,EAAAA,IAAwBC,EAAAA,IAC1DC,GAAYC,EAAAA,EAAAA,IAAuBC,EAAAA,IAUnCC,EAAe,MACnBC,EAAAA,EAAAA,IAAgBjB,EAAe3P,EAAUC,QAAQ4Q,QAAU,EAAI7Q,EAAUC,QAAQ6Q,WA2B7EC,EAAiCC,IACrC,MAAMnF,EAAOoF,SAASC,cAAc,8CAC/BrF,IAILA,EAAKN,UAAYyF,IAGbG,EAA0B,KAC1BpB,GACFA,EAAmBrO,OAGrBsO,GAA4B,EAE5BD,EAAqB,IAAIqB,EAAmBpR,EAAUC,SACtD8P,EAAmBpL,aAAa6L,GAChCT,EAAmBhB,UACnB6B,EAAAA,EAAAA,IAAgBhB,GAA8B,GAE9CmB,EAA+B,8BAG3BM,EAAyB,KACzBtB,GACFA,EAAmBb,UAErBa,EAAqB,KACrBC,GAA4B,GAC5BY,EAAAA,EAAAA,IAAgBhB,GAA8B,GAC9CmB,EACE,kFAIEO,EAA2B,KAC3BtB,EACFqB,IAEAF,KAqBEI,EAAiB/I,MAAOrI,EAAQC,KACpC,MAAMoR,QAvHVhJ,iBACE,IAAI+B,EAAY,GAEhB,IACE,MAAMF,QAAiBxI,MAnBF,uBAoBrB0I,QAAkBF,EAASoH,OAC3B,MAAO3P,GACPzB,QAAQ0B,MAAMD,GAEhB,OAAOyI,EA8GwBmH,GACvBrF,EAAasF,EACjBxR,EACAC,EACAoR,EACAF,GAEFnR,EAAOyR,WAAWC,SAChBxF,EACA,GAEAlM,EAAOyR,WAAWE,UAAU9J,OAAS,GA7BT7H,CAAAA,IAC9B,MAAM4E,EAAO5E,EAAO4E,KAAK,CAAEC,0BAA0B,IAGrD,IAAKD,IAASA,EAAKmC,IACjB,OAKqC,UAFA6K,EAAAA,EAAAA,IAAgBnC,IAEN7K,GAAQA,EAAKmC,IAC5DiK,IAEAE,KAkBFW,CAAwB7R,IAGpB8R,EAAe,CAAC9R,EAAQC,KAE5B,GAAI8R,OAAOC,eAAe,yCAA0C,CAClE,MAAMC,EAAiBhS,EAAQsK,aAAa,UAE5C,MAAM2H,UAA4BD,EAMhCE,cACE,IACuBrB,SAASsB,qBAAqB,SAAS,GACtCC,iCACtB,MAAO1Q,GACPzB,QAAQ0B,MAAMD,IAVlB8H,cACE0B,MAAMnL,IAcV,MAAMsS,EAAO,IAAIJ,EACclS,EAAOyR,WAAWC,SAASY,GACnCnG,SAAS,kBAKpCoG,EAAAA,EAAAA,IAAW,SAAS5Q,IAClBA,EAAE6Q,iBAlIE3S,EAAUC,QAAQkH,SACpBnH,EAAUC,QAAQ2S,OAElB5S,EAAUC,QAAQ4S,YAoItBH,EAAAA,EAAAA,IAAW,KAxHc,KACnB1S,EAAUC,QAAQ6S,eACpB9S,EAAUC,QAAQ8S,iBAElB/S,EAAUC,QAAQ+S,sBAoHY,CAChCC,yBAAyB,KAI3BP,EAAAA,EAAAA,IAAW,KArIQ,KACb1S,EAAUC,QAAQ4Q,SAA0C,IAA/B7Q,EAAUC,QAAQ6Q,SACjD9Q,EAAUC,QAAQ6Q,OAAO,IAEzB9Q,EAAUC,QAAQ6Q,OAAO,KAiID,CAC1BmC,yBAAyB,KAG3BP,EAAAA,EAAAA,IAAW,KAAK,IAAM1S,EAAUC,QAAQ6Q,OAAO9Q,EAAUC,QAAQ6Q,SAAW,KAAM,CAChFmC,yBAAyB,KAE3BP,EAAAA,EAAAA,IAAW,KAAK,IAAM1S,EAAUC,QAAQ6Q,OAAO9Q,EAAUC,QAAQ6Q,SAAW,KAAM,CAChFmC,yBAAyB,IAG3B,MAAMC,EAAiB,CACrB3S,UAAU,EACV4S,UAAU,EACVC,YAAY,EACZC,OAAO,EACPC,aAAa,EACbC,QAAQ,EACRC,QAAS,OACT3C,MAAOV,EACPyB,WAAY,CACV6B,gBAAiB,CACfC,SAAS,IAGbC,MAAO,CACLzM,IAAK,CAEH0M,0BAA0B,EAC1BC,4BAA4B,EAC5BC,0BAA0B,EAC1BC,mBAAoB,KAGxBxE,YAAa,CACXyE,kBAAmB,EACnBC,cAAe,IAEjBxT,QAAS,CACP,CACED,IAAK0P,EACLgE,KAAM,2BA8DZ,OAdA5P,EAAAA,EAAAA,YAAU,KACJwL,GACFA,EAAgBnL,aAAa6L,KAE9B,CAACA,KAEJlM,EAAAA,EAAAA,YACE,IAAM,KACJ+M,IACAvB,OAAAA,QAAAA,IAAAA,GAAAA,EAAiBpO,SAEnB,KAIA,UAACR,MAAAA,CAAII,UAAWC,IAAAA,U,UACb0C,IACC,SAAC/C,MAAAA,CAAII,UAAWC,IAAAA,O,UACd,SAAC5B,EAAOA,CAACC,QAASsT,EAAgBrT,QA7DhB,CAACM,EAAQC,KACjCJ,EAAUC,QAAUE,EAxMC,MACrB,IACEH,EAAUC,QAAQ6Q,QAAOiB,EAAAA,EAAAA,IAAgBpC,IAAkB,GAC3D,MAAOrH,GACPjI,QAAQkI,KAAKD,KAqMf6L,GACAlC,EAAa9R,EAAQC,GAGrBD,EAAO+E,GAAG,WAAW,KACnB7E,QAAQC,MAAM,wBAGhBH,EAAO+E,GAAG,WAAW,KACnB7E,QAAQC,MAAM,uBACd0B,EAAKN,UAGPvB,EAAO+E,GAAG,WAAW,KACnB7E,QAAQC,MAAM,qBACd0B,EAAKR,QACL6O,GAAgB,MAGlBlQ,EAAO+E,GAAG,SAAS,KACjB7E,QAAQC,MAAM,oBACd0B,EAAKN,OACL2O,GAAgB,MAGlBlQ,EAAO+E,GAAG,SAAS,KACjB7E,QAAQC,MAAM,mBACd0B,EAAKN,OACL2O,GAAgB,MAGlBjQ,EAAQgU,WAERjU,EAAO+E,GAAG,eAAgByL,GAE1Bb,EAAkB,IAAIuE,EAAgBlU,EAAQC,GAC9C0P,EAAgBnL,aAAa6L,GAE7Be,EAAepR,EAAQC,SAwBrB,SAACc,MAAAA,CAAII,UAAWC,IAAAA,O,UACZ6O,IACA,SAACpM,EAAWA,CAACC,OAAQA,EAAQC,WAAW,iBAAiB1D,IAAI,yBAMvE,S,kBCjUA8T,EAAOC,QAAU,CAAC,UAAY,iCAAiC,OAAS,8BAA8B,OAAS,gC,kBCA/GD,EAAOC,QAAU,CAAC,OAAS,0B,kBCA3BD,EAAOC,QAAU,CAAC,OAAS,8B","sources":["webpack://_N_E/./components/video/VideoJS/VideoJS.tsx","webpack://_N_E/./components/video/viewer-ping.ts","webpack://_N_E/./components/ui/CrossfadeImage/CrossfadeImage.tsx","webpack://_N_E/./components/video/VideoPoster/VideoPoster.tsx","webpack://_N_E/./components/video/metrics/playback.js","webpack://_N_E/./components/video/settings-menu.ts","webpack://_N_E/./components/video/latencyCompensator.js","webpack://_N_E/./components/video/OwncastPlayer/OwncastPlayer.tsx","webpack://_N_E/./components/video/OwncastPlayer/OwncastPlayer.module.scss","webpack://_N_E/./components/video/VideoJS/VideoJS.module.scss","webpack://_N_E/./components/video/VideoPoster/VideoPoster.module.scss"],"sourcesContent":["import React, { FC } from 'react';\nimport videojs, { VideoJsPlayer, VideoJsPlayerOptions } from 'video.js';\nimport styles from './VideoJS.module.scss';\n\nrequire('video.js/dist/video-js.css');\n\nexport type VideoJSProps = {\n  options: VideoJsPlayerOptions;\n  onReady: (player: videojs.Player, vjsInstance: typeof videojs) => void;\n};\n\nexport const VideoJS: FC<VideoJSProps> = ({ options, onReady }) => {\n  const videoRef = React.useRef<HTMLVideoElement | null>(null);\n  const playerRef = React.useRef<VideoJsPlayer | null>(null);\n\n  React.useEffect(() => {\n    // Make sure Video.js player is only initialized once\n    if (!playerRef.current) {\n      const videoElement = videoRef.current;\n\n      // eslint-disable-next-line no-multi-assign\n      const player: VideoJsPlayer = (playerRef.current = videojs(videoElement, options, () => {\n        console.debug('player is ready');\n        return onReady && onReady(player, videojs);\n      }));\n\n      player.autoplay(options.autoplay);\n      player.src(options.sources);\n    }\n\n    // Add a cachebuster param to playlist URLs.\n    videojs.Vhs.xhr.beforeRequest = o => {\n      if (o.uri.match('m3u8')) {\n        const cachebuster = Math.random().toString(16).substr(2, 8);\n        // eslint-disable-next-line no-param-reassign\n        o.uri = `${o.uri}?cachebust=${cachebuster}`;\n      }\n\n      return o;\n    };\n  }, [options, videoRef]);\n\n  return (\n    <div data-vjs-player>\n      {/* eslint-disable-next-line jsx-a11y/media-has-caption */}\n      <video\n        ref={videoRef}\n        className={`video-js vjs-big-play-centered vjs-show-big-play-button-on-pause ${styles.player} vjs-owncast`}\n      />\n    </div>\n  );\n};\n\nexport default VideoJS;\n","const URL = '/api/ping';\nconst INTERVAL = 4000;\n\nfunction ping() {\n  try {\n    fetch(URL);\n  } catch (e) {\n    console.error(e);\n  }\n}\n\nclass ViewerPing {\n  timer: ReturnType<typeof setInterval>;\n\n  start() {\n    this.stop();\n\n    this.timer = setInterval(() => {\n      ping();\n    }, INTERVAL);\n  }\n\n  stop() {\n    clearInterval(this.timer);\n  }\n}\n\nexport default ViewerPing;\n","import React, { FC, useMemo, useState } from 'react';\n\ntype ObjectFit = React.CSSProperties['objectFit'];\n\nexport type CrossfadeImageProps = {\n  src: string;\n  width: string;\n  height: string;\n  objectFit?: ObjectFit;\n  duration?: string;\n};\n\nconst imgStyle: React.CSSProperties = {\n  position: 'absolute',\n  width: `100%`,\n  height: `100%`,\n};\n\nexport const CrossfadeImage: FC<CrossfadeImageProps> = ({\n  src = '',\n  width,\n  height,\n  objectFit = 'fill',\n  duration = '1s',\n}) => {\n  const spanStyle: React.CSSProperties = useMemo(\n    () => ({\n      display: 'inline-block',\n      position: 'relative',\n      width,\n      height,\n    }),\n    [width, height],\n  );\n\n  const imgStyles = useMemo(\n    () => [\n      { ...imgStyle, objectFit, opacity: 0, transition: `opacity ${duration}` },\n      { ...imgStyle, objectFit, opacity: 1, transition: `opacity ${duration}` },\n      { ...imgStyle, objectFit, opacity: 0 },\n    ],\n    [objectFit, duration],\n  );\n\n  const [key, setKey] = useState(0);\n  const [srcs, setSrcs] = useState(['', '']);\n  const nextSrc = src !== srcs[1] ? src : '';\n\n  const onLoadImg = () => {\n    setKey((key + 1) % 3);\n    setSrcs([srcs[1], nextSrc]);\n  };\n\n  return (\n    <span style={spanStyle}>\n      {[...srcs, nextSrc].map(\n        (singleSrc, index) =>\n          singleSrc !== '' && (\n            <img\n              key={singleSrc}\n              src={singleSrc}\n              alt=\"\"\n              style={imgStyles[index]}\n              onLoad={index === 2 ? onLoadImg : undefined}\n            />\n          ),\n      )}\n    </span>\n  );\n};\nexport default CrossfadeImage;\n\nCrossfadeImage.defaultProps = {\n  objectFit: 'fill',\n  duration: '3s',\n};\n","import { FC, useEffect, useState } from 'react';\nimport { CrossfadeImage } from '../../ui/CrossfadeImage/CrossfadeImage';\nimport styles from './VideoPoster.module.scss';\n\nconst REFRESH_INTERVAL = 20_000;\n\nexport type VideoPosterProps = {\n  initialSrc: string;\n  src: string;\n  online: boolean;\n};\n\nexport const VideoPoster: FC<VideoPosterProps> = ({ online, initialSrc, src: base }) => {\n  let timer: ReturnType<typeof setInterval>;\n  const [src, setSrc] = useState(initialSrc);\n  const [duration, setDuration] = useState('0s');\n\n  useEffect(() => {\n    clearInterval(timer);\n    timer = setInterval(() => {\n      if (duration === '0s') {\n        setDuration('3s');\n      }\n      setSrc(`${base}?${Date.now()}`);\n    }, REFRESH_INTERVAL);\n  }, []);\n\n  return (\n    <div className={styles.poster}>\n      {!online && <img src={initialSrc} alt=\"logo\" />}\n\n      {online && (\n        <CrossfadeImage\n          src={src}\n          duration={duration}\n          objectFit=\"cover\"\n          width=\"100%\"\n          height=\"100%\"\n        />\n      )}\n    </div>\n  );\n};\n","/* eslint-disable no-plusplus */\nconst URL_PLAYBACK_METRICS = `/api/metrics/playback`;\nconst METRICS_SEND_INTERVAL = 10000;\nconst MAX_VALID_LATENCY_SECONDS = 40; // Anything > this gets thrown out.\n\nfunction getCurrentlyPlayingSegment(tech) {\n  const targetMedia = tech.vhs.playlists.media();\n  const snapshotTime = tech.currentTime();\n  let segment;\n\n  // Iterate trough available segments and get first within which snapshot_time is\n  // eslint-disable-next-line no-plusplus\n  for (let i = 0, l = targetMedia.segments.length; i < l; i++) {\n    // Note: segment.end may be undefined or is not properly set\n    if (snapshotTime < targetMedia.segments[i].end) {\n      segment = targetMedia.segments[i];\n      break;\n    }\n  }\n\n  if (!segment) {\n    [segment] = targetMedia.segments;\n  }\n\n  return segment;\n}\n\nclass PlaybackMetrics {\n  constructor(player, videojs) {\n    this.player = player;\n    this.supportsDetailedMetrics = false;\n    this.hasPerformedInitialVariantChange = false;\n    this.clockSkewMs = 0;\n\n    this.segmentDownloadTime = [];\n    this.bandwidthTracking = [];\n    this.latencyTracking = [];\n    this.errors = 0;\n    this.qualityVariantChanges = 0;\n    this.isBuffering = false;\n    this.bufferingDurationTimer = 0;\n    this.collectPlaybackMetricsTimer = 0;\n\n    this.videoJSReady = this.videoJSReady.bind(this);\n    this.handlePlaying = this.handlePlaying.bind(this);\n    this.handleBuffering = this.handleBuffering.bind(this);\n    this.handleEnded = this.handleEnded.bind(this);\n    this.handleError = this.handleError.bind(this);\n    this.send = this.send.bind(this);\n    this.collectPlaybackMetrics = this.collectPlaybackMetrics.bind(this);\n    this.handleNoLongerBuffering = this.handleNoLongerBuffering.bind(this);\n    this.sendMetricsTimer = 0;\n\n    this.player.on('canplaythrough', this.handleNoLongerBuffering);\n    this.player.on('error', this.handleError);\n    this.player.on('stalled', this.handleBuffering);\n    this.player.on('waiting', this.handleBuffering);\n    this.player.on('playing', this.handlePlaying);\n    this.player.on('ended', this.handleEnded);\n\n    // Keep a reference of the standard vjs xhr function.\n    const oldVjsXhrCallback = videojs.xhr;\n\n    // Override the xhr function to track segment download time.\n    // eslint-disable-next-line no-param-reassign\n    videojs.Vhs.xhr = (...args) => {\n      if (args[0].uri.match('.ts')) {\n        const start = new Date();\n\n        const cb = args[1];\n        // eslint-disable-next-line no-param-reassign\n        args[1] = (request, error, response) => {\n          const end = new Date();\n          const delta = end.getTime() - start.getTime();\n          this.trackSegmentDownloadTime(delta);\n          cb(request, error, response);\n        };\n      }\n\n      return oldVjsXhrCallback(...args);\n    };\n\n    this.videoJSReady();\n\n    this.sendMetricsTimer = setInterval(() => {\n      this.send();\n    }, METRICS_SEND_INTERVAL);\n  }\n\n  stop() {\n    clearInterval(this.sendMetricsTimer);\n    this.player.off();\n  }\n\n  // Keep our client clock in sync with the server clock to determine\n  // accurate latency calculations.\n  setClockSkew(skewMs) {\n    this.clockSkewMs = skewMs;\n  }\n\n  videoJSReady() {\n    const tech = this.player.tech({ IWillNotUseThisInPlugins: true });\n    this.supportsDetailedMetrics = !!tech;\n\n    tech.on('usage', e => {\n      if (e.name === 'vhs-unknown-waiting') {\n        this.setIsBuffering(true);\n      }\n\n      if (e.name === 'vhs-rendition-change-abr') {\n        // Quality variant has changed\n        this.incrementQualityVariantChanges();\n      }\n    });\n\n    // Variant changed\n    const trackElements = this.player.textTracks();\n    trackElements.addEventListener('cuechange', () => {\n      this.incrementQualityVariantChanges();\n    });\n  }\n\n  handlePlaying() {\n    clearInterval(this.collectPlaybackMetricsTimer);\n    this.collectPlaybackMetricsTimer = setInterval(() => {\n      this.collectPlaybackMetrics();\n    }, 5000);\n  }\n\n  handleEnded() {\n    clearInterval(this.collectPlaybackMetricsTimer);\n  }\n\n  handleBuffering() {\n    this.incrementErrorCount(1);\n    this.setIsBuffering(true);\n  }\n\n  handleNoLongerBuffering() {\n    this.setIsBuffering(false);\n  }\n\n  handleError() {\n    this.incrementErrorCount(1);\n  }\n\n  incrementErrorCount(count) {\n    this.errors += count;\n  }\n\n  incrementQualityVariantChanges() {\n    // We always start the player at the lowest quality, so let's just not\n    // count the first change.\n    if (!this.hasPerformedInitialVariantChange) {\n      this.hasPerformedInitialVariantChange = true;\n      return;\n    }\n    this.qualityVariantChanges++;\n  }\n\n  setIsBuffering(isBuffering) {\n    this.isBuffering = isBuffering;\n\n    if (!isBuffering) {\n      clearTimeout(this.bufferingDurationTimer);\n      return;\n    }\n\n    this.bufferingDurationTimer = setTimeout(() => {\n      this.incrementErrorCount(1);\n    }, 500);\n  }\n\n  trackSegmentDownloadTime(seconds) {\n    this.segmentDownloadTime.push(seconds);\n  }\n\n  trackBandwidth(bps) {\n    this.bandwidthTracking.push(bps);\n  }\n\n  trackLatency(latency) {\n    this.latencyTracking.push(latency);\n  }\n\n  collectPlaybackMetrics() {\n    const tech = this.player.tech({ IWillNotUseThisInPlugins: true });\n    if (!tech || !tech.vhs) {\n      return;\n    }\n\n    // If we're paused then do nothing.\n    if (this.player.paused()) {\n      return;\n    }\n\n    // Network state 2 means we're actively using the network.\n    // We only care about reporting metrics with network activity stats\n    // if it's actively being used, so don't report otherwise.\n    const networkState = this.player.networkState();\n    if (networkState !== 2) {\n      return;\n    }\n\n    const bandwidth = tech.vhs.systemBandwidth;\n    this.trackBandwidth(bandwidth);\n\n    try {\n      const segment = getCurrentlyPlayingSegment(tech);\n      if (!segment || !segment.dateTimeObject) {\n        return;\n      }\n\n      const segmentTime = segment.dateTimeObject.getTime();\n      const now = new Date().getTime() + this.clockSkewMs;\n      const latency = now - segmentTime;\n\n      // Throw away values that seem invalid.\n      if (latency < 0 || latency / 1000 >= MAX_VALID_LATENCY_SECONDS) {\n        return;\n      }\n\n      this.trackLatency(latency);\n    } catch (err) {\n      console.warn(err);\n    }\n  }\n\n  async send() {\n    if (this.segmentDownloadTime.length === 0) {\n      return;\n    }\n\n    // If we're paused then do nothing.\n    if (!this.player || this.player.paused()) {\n      return;\n    }\n\n    const errorCount = this.errors;\n\n    let data;\n    if (this.supportsDetailedMetrics) {\n      const average = arr => arr.reduce((p, c) => p + c, 0) / arr.length;\n\n      const averageDownloadDuration = average(this.segmentDownloadTime) / 1000;\n      const roundedAverageDownloadDuration = Math.round(averageDownloadDuration * 1000) / 1000;\n\n      const averageBandwidth = average(this.bandwidthTracking) / 1000;\n      const roundedAverageBandwidth = Math.round(averageBandwidth * 1000) / 1000;\n\n      const averageLatency = average(this.latencyTracking) / 1000;\n      const roundedAverageLatency = Math.round(averageLatency * 1000) / 1000;\n\n      data = {\n        bandwidth: roundedAverageBandwidth,\n        latency: roundedAverageLatency,\n        downloadDuration: roundedAverageDownloadDuration,\n        errors: errorCount + (this.isBuffering ? 1 : 0),\n        qualityVariantChanges: this.qualityVariantChanges,\n      };\n    } else {\n      data = {\n        errors: errorCount + (this.isBuffering ? 1 : 0),\n      };\n    }\n\n    this.errors = 0;\n    this.qualityVariantChanges = 0;\n    this.segmentDownloadTime = [];\n    this.bandwidthTracking = [];\n    this.latencyTracking = [];\n\n    const options = {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(data),\n    };\n\n    try {\n      await fetch(URL_PLAYBACK_METRICS, options);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\n\nexport default PlaybackMetrics;\n","/* eslint-disable max-classes-per-file */\nexport function createVideoSettingsMenuButton(player, videojs, qualities, latencyItemPressed): any {\n  const VjsMenuItem = videojs.getComponent('MenuItem');\n  const MenuItem = videojs.getComponent('MenuItem');\n  const MenuButtonClass = videojs.getComponent('MenuButton');\n\n  class MenuSeparator extends VjsMenuItem {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(p: any, options: { selectable: boolean }) {\n      super(p, options);\n    }\n\n    createEl(tag = 'button', props = {}, attributes = {}) {\n      const el = super.createEl(tag, props, attributes);\n      el.innerHTML = '<hr style=\"opacity: 0.3; margin-left: 10px; margin-right: 10px;\" />';\n      return el;\n    }\n  }\n\n  const lowLatencyItem = new MenuItem(player, {\n    selectable: true,\n  });\n  lowLatencyItem.setAttribute('class', 'latency-toggle-item');\n  lowLatencyItem.on('click', () => {\n    latencyItemPressed();\n  });\n\n  const separator = new MenuSeparator(player, {\n    selectable: false,\n  });\n\n  class MenuButton extends MenuButtonClass {\n    constructor() {\n      super(player);\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    createItems() {\n      const tech = player.tech({ IWillNotUseThisInPlugins: true });\n\n      const defaultAutoItem = new MenuItem(player, {\n        selectable: true,\n        label: 'Auto',\n      });\n\n      const items = qualities.map(item => {\n        const newMenuItem = new MenuItem(player, {\n          selectable: true,\n          label: item.name,\n        });\n\n        // Quality selected\n        newMenuItem.on('click', () => {\n          // If for some reason tech doesn't exist, then don't do anything\n          if (!tech) {\n            console.warn('Invalid attempt to access null player tech');\n            return;\n          }\n          // Only enable this single, selected representation.\n          tech.vhs.representations().forEach((rep, index) => {\n            rep.enabled(index === item.index);\n          });\n          newMenuItem.selected(false);\n        });\n\n        return newMenuItem;\n      });\n\n      defaultAutoItem.on('click', () => {\n        // Re-enable all representations.\n        tech.vhs.representations().forEach(rep => {\n          rep.enabled(true);\n        });\n        defaultAutoItem.selected(false);\n      });\n\n      const supportsLatencyCompensator = !!tech && !!tech.vhs;\n\n      // Only show the quality selector if there is more than one option.\n      if (qualities.length < 2 && supportsLatencyCompensator) {\n        return [lowLatencyItem];\n      }\n\n      if (qualities.length > 1 && supportsLatencyCompensator) {\n        return [defaultAutoItem, ...items, separator, lowLatencyItem];\n      }\n      if (!supportsLatencyCompensator && qualities.length === 1) {\n        return [];\n      }\n\n      return [defaultAutoItem, ...items];\n    }\n  }\n\n  const menuButton = new MenuButton();\n\n  // If none of the settings in this menu are applicable then don't show it.\n  const tech = player.tech({ IWillNotUseThisInPlugins: true });\n  menuButton.addClass('vjs-quality-selector');\n  videojs.registerComponent('MenuButton', MenuButton);\n\n  if (!tech.vhs) {\n    return menuButton;\n  }\n\n  if (qualities.length < 2 && (!tech || !tech.vhs)) {\n    return menuButton;\n  }\n\n  // eslint-disable-next-line consistent-return\n  return menuButton;\n}\n\nexport default createVideoSettingsMenuButton;\n","/*\nThe Owncast Latency Compensator.\n\nIt will try to slowly adjust the playback rate to enable the player to get\nfurther into the future, with the goal of being as close to the live edge as\npossible, without causing any buffering events.\n\nHow does latency occur?\nTwo pieces are at play. The first being the server. The larger each segment is\nthat is being generated by Owncast, the larger gap you are going to be from\nlive when you begin playback.\n\nSecond is your media player.\nThe player tries to play every segment as it comes in.\nHowever, your computer is not always 100% in playing things in real time, and\nthere are natural stutters in playback. So if one frame is delayed in playback\nyou may not see it visually, but now you're one frame behind. Eventually this\ncan compound and you can be many seconds behind.\n\nHow to help with this? The Owncast Latency Compensator will:\n  - Determine the start (max) and end (min) latency values.\n  - Keep an eye on download speed and stop compensating if it drops too low.\n  - Limit the playback speedup rate so it doesn't sound weird by jumping speeds.\n  - Force a large jump to into the future once compensation begins.\n  - Dynamically calculate the speedup rate based on network speed.\n  - Pause the compensation if buffering events occur.\n  - Completely give up on all compensation if too many buffering events occur.\n*/\n\nconst REBUFFER_EVENT_LIMIT = 4; // Max number of buffering events before we stop compensating for latency.\nconst MIN_BUFFER_DURATION = 200; // Min duration a buffer event must last to be counted.\nconst MAX_SPEEDUP_RATE = 1.08; // The playback rate when compensating for latency.\nconst MAX_SPEEDUP_RAMP = 0.02; // The max amount we will increase the playback rate at once.\nconst TIMEOUT_DURATION = 30 * 1000; // The amount of time we stop handling latency after certain events.\nconst CHECK_TIMER_INTERVAL = 3 * 1000; // How often we check if we should be compensating for latency.\nconst BUFFERING_AMNESTY_DURATION = 3 * 1000 * 60; // How often until a buffering event expires.\nconst REQUIRED_BANDWIDTH_RATIO = 1.8; // The player:bitrate ratio required to enable compensating for latency.\nconst HIGHEST_LATENCY_SEGMENT_LENGTH_MULTIPLIER = 2.6; // Segment length * this value is when we start compensating.\nconst LOWEST_LATENCY_SEGMENT_LENGTH_MULTIPLIER = 1.8; // Segment length * this value is when we stop compensating.\nconst MIN_LATENCY = 4 * 1000; // The absolute lowest we'll continue compensation to be running at.\nconst MAX_LATENCY = 15 * 1000; // The absolute highest we'll allow a target latency to be before we start compensating.\nconst MAX_JUMP_LATENCY = 5 * 1000; // How much behind the max latency we need to be behind before we allow a jump.\nconst MAX_JUMP_FREQUENCY = 20 * 1000; // How often we'll allow a time jump.\nconst MAX_ACTIONABLE_LATENCY = 80 * 1000; // If latency is seen to be greater than this then something is wrong.\nconst STARTUP_WAIT_TIME = 10 * 1000; // The amount of time after we start up that we'll allow monitoring to occur.\n\nfunction getCurrentlyPlayingSegment(tech) {\n  const targetMedia = tech.vhs.playlists.media();\n  const snapshotTime = tech.currentTime();\n  let segment;\n\n  // Iterate trough available segments and get first within which snapshot_time is\n  // eslint-disable-next-line no-plusplus\n  for (let i = 0, l = targetMedia.segments.length; i < l; i++) {\n    // Note: segment.end may be undefined or is not properly set\n    if (snapshotTime < targetMedia.segments[i].end) {\n      segment = targetMedia.segments[i];\n      break;\n    }\n  }\n\n  if (!segment) {\n    [segment] = targetMedia.segments;\n  }\n\n  return segment;\n}\n\nclass LatencyCompensator {\n  constructor(player) {\n    this.player = player;\n    this.playing = false;\n    this.enabled = false;\n    this.running = false;\n    this.inTimeout = false;\n    this.jumpingToLiveIgnoreBuffer = false;\n    this.timeoutTimer = 0;\n    this.checkTimer = 0;\n    this.bufferingCounter = 0;\n    this.bufferingTimer = 0;\n    this.playbackRate = 1.0;\n    this.lastJumpOccurred = null;\n    this.startupTime = new Date();\n    this.clockSkewMs = 0;\n    this.currentLatency = null;\n\n    // Keep track of all the latencies we encountered buffering events\n    // in order to determine a new minimum latency.\n    this.bufferedAtLatency = [];\n\n    this.player.on('playing', this.handlePlaying.bind(this));\n    this.player.on('pause', this.handlePause.bind(this));\n    this.player.on('error', this.handleError.bind(this));\n    this.player.on('waiting', this.handleBuffering.bind(this));\n    this.player.on('stalled', this.handleBuffering.bind(this));\n    this.player.on('ended', this.handleEnded.bind(this));\n    this.player.on('canplaythrough', this.handlePlaying.bind(this));\n    this.player.on('canplay', this.handlePlaying.bind(this));\n\n    this.check = this.check.bind(this);\n    this.start = this.start.bind(this);\n    this.enable = this.enable.bind(this);\n    this.countBufferingEvent = this.countBufferingEvent.bind(this);\n  }\n\n  // To keep our client clock in sync with the server clock to determine\n  // accurate latency the clock skew should be set here to be used in\n  // the calculation. Otherwise if somebody's client clock is significantly\n  // off it will have a very incorrect latency determination and make bad\n  // decisions.\n  setClockSkew(skewMs) {\n    this.clockSkewMs = skewMs;\n  }\n\n  // This is run on a timer to check if we should be compensating for latency.\n  check() {\n    // We have an arbitrary delay at startup to allow the player to run\n    // normally and hopefully get a bit of a buffer of segments before we\n    // start messing with it.\n    if (new Date().getTime() - this.startupTime.getTime() < STARTUP_WAIT_TIME) {\n      return;\n    }\n\n    // If we're paused then do nothing.\n    if (this.player.paused()) {\n      return;\n    }\n\n    if (this.player.seeking()) {\n      return;\n    }\n\n    if (this.inTimeout) {\n      return;\n    }\n\n    if (!this.enabled) {\n      return;\n    }\n\n    const tech = this.player.tech({ IWillNotUseThisInPlugins: true });\n\n    // We need access to the internal tech of VHS to move forward.\n    // If running under an Apple browser that uses CoreMedia (Safari)\n    // we do not have access to this as the tech is internal to the OS.\n    if (!tech || !tech.vhs) {\n      return;\n    }\n\n    // Network state 2 means we're actively using the network.\n    // We only want to attempt latency compensation if we're continuing to\n    // download new segments.\n    const networkState = this.player.networkState();\n    if (networkState !== 2) {\n      return;\n    }\n\n    let totalBuffered = 0;\n\n    try {\n      // Check the player buffers to make sure there's enough playable content\n      // that we can safely play.\n      if (tech.vhs.stats.buffered.length === 0) {\n        this.timeout();\n        return;\n      }\n\n      tech.vhs.stats.buffered.forEach(buffer => {\n        totalBuffered += buffer.end - buffer.start;\n      });\n    } catch (e) {\n      console.error(e);\n    }\n\n    // Determine how much of the current playlist's bandwidth requirements\n    // we're utilizing. If it's too high then we can't afford to push\n    // further into the future because we're downloading too slowly.\n    const currentPlaylist = tech.vhs.playlists.media();\n    const currentPlaylistBandwidth = currentPlaylist.attributes.BANDWIDTH;\n    const playerBandwidth = tech.vhs.systemBandwidth;\n    const bandwidthRatio = playerBandwidth / currentPlaylistBandwidth;\n\n    try {\n      const segment = getCurrentlyPlayingSegment(tech);\n      if (!segment) {\n        return;\n      }\n\n      // If we're downloading media fast enough or we feel like we have a large\n      // enough buffer then continue. Otherwise timeout for a bit.\n      if (bandwidthRatio < REQUIRED_BANDWIDTH_RATIO && totalBuffered < segment.duration * 6) {\n        this.timeout();\n        return;\n      }\n\n      // How far away from live edge do we stop the compensator.\n      const computedMinLatencyThreshold = Math.max(\n        MIN_LATENCY,\n        segment.duration * 1000 * LOWEST_LATENCY_SEGMENT_LENGTH_MULTIPLIER,\n      );\n\n      // Create an array of all the buffering events in the past along with\n      // the computed min latency above.\n      const targetLatencies = this.bufferedAtLatency.concat([computedMinLatencyThreshold]);\n\n      // Determine if we need to reduce the minimum latency we computed\n      // above based on buffering events that have taken place in the past by\n      // creating an array of all the buffering events and the above computed\n      // minimum latency target and averaging all those values.\n      const minLatencyThreshold =\n        targetLatencies.reduce((sum, current) => sum + current, 0) / targetLatencies.length;\n\n      // How far away from live edge do we start the compensator.\n      let maxLatencyThreshold = Math.max(\n        minLatencyThreshold * 1.4,\n        Math.min(segment.duration * 1000 * HIGHEST_LATENCY_SEGMENT_LENGTH_MULTIPLIER, MAX_LATENCY),\n      );\n\n      // If this newly adjusted minimum latency ends up being greater than\n      // the previously computed maximum latency then reset the maximum\n      // value using the minimum + an offset.\n      if (minLatencyThreshold >= maxLatencyThreshold) {\n        maxLatencyThreshold = minLatencyThreshold + 3000;\n      }\n\n      const segmentTime = segment.dateTimeObject.getTime();\n      const now = new Date().getTime() + this.clockSkewMs;\n      const latency = now - segmentTime;\n      this.currentLatency = latency;\n\n      // Since the calculation of latency is based on clock times, it's possible\n      // things can be reported incorrectly. So we use a sanity check here to\n      // simply bail if the latency is reported to so high we think the whole\n      // thing is wrong. We can't make decisions based on bad data, so give up.\n      // This can also occur if somebody pauses for a long time and hits play\n      // again but it's not really possible to know the difference between\n      // the two scenarios.\n      if (Math.abs(latency) > MAX_ACTIONABLE_LATENCY) {\n        this.timeout();\n        return;\n      }\n\n      if (latency > maxLatencyThreshold) {\n        // If the current latency exceeds the max jump amount then\n        // force jump into the future, skipping all the video in between.\n        if (this.shouldJumpToLive() && latency > maxLatencyThreshold + MAX_JUMP_LATENCY) {\n          const jumpAmount = latency / 1000 - segment.duration * 3;\n          const seekPosition = this.player.currentTime() + jumpAmount;\n          console.info(\n            'latency',\n            latency / 1000,\n            'jumping',\n            jumpAmount,\n            'to live from ',\n            this.player.currentTime(),\n            ' to ',\n            seekPosition,\n          );\n\n          // Verify we have the seek position buffered before jumping.\n          const availableBufferedTimeEnd = tech.vhs.stats.buffered[0].end;\n          const availableBufferedTimeStart = tech.vhs.stats.buffered[0].start;\n          if (seekPosition > availableBufferedTimeStart < availableBufferedTimeEnd) {\n            this.jump(seekPosition);\n\n            return;\n          }\n        }\n\n        // Using our bandwidth ratio determine a wide guess at how fast we can play.\n        let proposedPlaybackRate = bandwidthRatio * 0.33;\n\n        // But limit the playback rate to a max value.\n        proposedPlaybackRate = Math.max(Math.min(proposedPlaybackRate, MAX_SPEEDUP_RATE), 1.0);\n\n        if (proposedPlaybackRate > this.playbackRate + MAX_SPEEDUP_RAMP) {\n          // If this proposed speed is substantially faster than the current rate,\n          // then allow us to ramp up by using a slower value for now.\n          proposedPlaybackRate = this.playbackRate + MAX_SPEEDUP_RAMP;\n        }\n\n        // Limit to 3 decimal places of precision.\n        proposedPlaybackRate = Math.round(proposedPlaybackRate * 10 ** 3) / 10 ** 3;\n\n        // Otherwise start the playback rate adjustment.\n        this.start(proposedPlaybackRate);\n      } else if (latency <= minLatencyThreshold) {\n        this.stop();\n      }\n\n      console.info(\n        'latency',\n        latency / 1000,\n        'min',\n        minLatencyThreshold / 1000,\n        'max',\n        maxLatencyThreshold / 1000,\n        'playback rate',\n        this.playbackRate,\n        'enabled:',\n        this.enabled,\n        'running: ',\n        this.running,\n        'skew: ',\n        this.clockSkewMs,\n        'rebuffer events: ',\n        this.bufferingCounter,\n      );\n    } catch (err) {\n      // console.error(err);\n    }\n  }\n\n  shouldJumpToLive() {\n    // If we've been rebuffering some recently then don't make it worse by\n    // jumping more into the future.\n    if (this.bufferingCounter > 1) {\n      return false;\n    }\n\n    const now = new Date().getTime();\n    const delta = now - this.lastJumpOccurred;\n    return delta > MAX_JUMP_FREQUENCY;\n  }\n\n  jump(seekPosition) {\n    this.jumpingToLiveIgnoreBuffer = true;\n    this.performedInitialLiveJump = true;\n\n    this.lastJumpOccurred = new Date();\n\n    console.info('current time', this.player.currentTime(), 'seeking to', seekPosition);\n    this.player.currentTime(seekPosition);\n\n    setTimeout(() => {\n      this.jumpingToLiveIgnoreBuffer = false;\n    }, 5000);\n  }\n\n  setPlaybackRate(rate) {\n    this.playbackRate = rate;\n    this.player.playbackRate(rate);\n  }\n\n  start(rate = 1.0) {\n    if (this.inTimeout || !this.enabled || rate === this.playbackRate) {\n      return;\n    }\n\n    this.running = true;\n    this.setPlaybackRate(rate);\n  }\n\n  stop() {\n    if (this.running) {\n      console.log('stopping latency compensator...');\n    }\n    this.running = false;\n    this.setPlaybackRate(1.0);\n  }\n\n  enable() {\n    this.enabled = true;\n    clearInterval(this.checkTimer);\n    clearTimeout(this.bufferingTimer);\n\n    this.checkTimer = setInterval(() => {\n      this.check();\n    }, CHECK_TIMER_INTERVAL);\n  }\n\n  // Disable means we're done for good and should no longer compensate for latency.\n  disable() {\n    clearInterval(this.checkTimer);\n    clearTimeout(this.timeoutTimer);\n    this.stop();\n    this.enabled = false;\n  }\n\n  timeout() {\n    if (this.jumpingToLiveIgnoreBuffer) {\n      return;\n    }\n\n    this.inTimeout = true;\n    this.stop();\n\n    clearTimeout(this.timeoutTimer);\n    this.timeoutTimer = setTimeout(() => {\n      this.endTimeout();\n    }, TIMEOUT_DURATION);\n  }\n\n  endTimeout() {\n    clearTimeout(this.timeoutTimer);\n    this.inTimeout = false;\n  }\n\n  handlePlaying() {\n    const wasPreviouslyPlaying = this.playing;\n    this.playing = true;\n\n    clearTimeout(this.bufferingTimer);\n    if (!this.enabled) {\n      return;\n    }\n\n    if (!this.shouldJumpToLive()) {\n      return;\n    }\n\n    // If we were not previously playing (was paused, or this is a cold start)\n    // seek to live immediately on starting playback to handle any long-pause\n    // scenarios or somebody starting far back from the live edge.\n    // If we were playing previously then that means we're probably coming back\n    // from a rebuffering event, meaning we should not be adding more seeking\n    // to the mix, just let it play.\n    if (!wasPreviouslyPlaying) {\n      this.jumpingToLiveIgnoreBuffer = true;\n      this.player.liveTracker.seekToLiveEdge();\n      this.lastJumpOccurred = new Date();\n    }\n  }\n\n  handlePause() {\n    this.playing = false;\n  }\n\n  handleEnded() {\n    if (!this.enabled) {\n      return;\n    }\n\n    this.disable();\n  }\n\n  handleError() {\n    if (!this.enabled) {\n      return;\n    }\n\n    this.timeout();\n  }\n\n  countBufferingEvent() {\n    this.bufferingCounter += 1;\n\n    if (this.bufferingCounter > REBUFFER_EVENT_LIMIT) {\n      this.disable();\n      return;\n    }\n\n    this.bufferedAtLatency.push(this.currentLatency);\n\n    console.log(\n      'latency compensation timeout due to buffering:',\n      this.bufferingCounter,\n      'buffering events of',\n      REBUFFER_EVENT_LIMIT,\n    );\n\n    // Allow us to forget about old buffering events if enough time goes by.\n    setTimeout(() => {\n      if (this.bufferingCounter > 0) {\n        this.bufferingCounter -= 1;\n      }\n    }, BUFFERING_AMNESTY_DURATION);\n  }\n\n  handleBuffering() {\n    if (!this.enabled || this.inTimeout) {\n      return;\n    }\n\n    if (this.jumpingToLiveIgnoreBuffer) {\n      this.jumpingToLiveIgnoreBuffer = false;\n      return;\n    }\n\n    this.timeout();\n\n    clearTimeout(this.bufferingTimer);\n    this.bufferingTimer = setTimeout(() => {\n      this.countBufferingEvent();\n    }, MIN_BUFFER_DURATION);\n  }\n}\n\nexport default LatencyCompensator;\n","import React, { FC, useEffect } from 'react';\nimport { useRecoilState, useRecoilValue } from 'recoil';\nimport { useHotkeys } from 'react-hotkeys-hook';\nimport { VideoJsPlayerOptions } from 'video.js';\nimport { VideoJS } from '../VideoJS/VideoJS';\nimport ViewerPing from '../viewer-ping';\nimport { VideoPoster } from '../VideoPoster/VideoPoster';\nimport { getLocalStorage, setLocalStorage } from '../../../utils/localStorage';\nimport { isVideoPlayingAtom, clockSkewAtom } from '../../stores/ClientConfigStore';\nimport PlaybackMetrics from '../metrics/playback';\nimport createVideoSettingsMenuButton from '../settings-menu';\nimport LatencyCompensator from '../latencyCompensator';\n\nimport styles from './OwncastPlayer.module.scss';\n\nconst VIDEO_CONFIG_URL = '/api/video/variants';\nconst PLAYER_VOLUME = 'owncast_volume';\nconst LATENCY_COMPENSATION_ENABLED = 'latencyCompensatorEnabled';\n\nconst ping = new ViewerPing();\nlet playbackMetrics = null;\nlet latencyCompensator = null;\nlet latencyCompensatorEnabled = false;\n\nexport type OwncastPlayerProps = {\n  source: string;\n  online: boolean;\n  initiallyMuted?: boolean;\n};\n\nasync function getVideoSettings() {\n  let qualities = [];\n\n  try {\n    const response = await fetch(VIDEO_CONFIG_URL);\n    qualities = await response.json();\n  } catch (e) {\n    console.error(e);\n  }\n  return qualities;\n}\n\nexport const OwncastPlayer: FC<OwncastPlayerProps> = ({\n  source,\n  online,\n  initiallyMuted = false,\n}) => {\n  const playerRef = React.useRef(null);\n  const [videoPlaying, setVideoPlaying] = useRecoilState<boolean>(isVideoPlayingAtom);\n  const clockSkew = useRecoilValue<Number>(clockSkewAtom);\n\n  const setSavedVolume = () => {\n    try {\n      playerRef.current.volume(getLocalStorage(PLAYER_VOLUME) || 1);\n    } catch (err) {\n      console.warn(err);\n    }\n  };\n\n  const handleVolume = () => {\n    setLocalStorage(PLAYER_VOLUME, playerRef.current.muted() ? 0 : playerRef.current.volume());\n  };\n\n  const togglePlayback = () => {\n    if (playerRef.current.paused()) {\n      playerRef.current.play();\n    } else {\n      playerRef.current.pause();\n    }\n  };\n\n  const toggleMute = () => {\n    if (playerRef.current.muted() || playerRef.current.volume() === 0) {\n      playerRef.current.volume(0.7);\n    } else {\n      playerRef.current.volume(0);\n    }\n  };\n\n  const toggleFullScreen = () => {\n    if (playerRef.current.isFullscreen()) {\n      playerRef.current.exitFullscreen();\n    } else {\n      playerRef.current.requestFullscreen();\n    }\n  };\n\n  const setLatencyCompensatorItemTitle = title => {\n    const item = document.querySelector('.latency-toggle-item > .vjs-menu-item-text');\n    if (!item) {\n      return;\n    }\n\n    item.innerHTML = title;\n  };\n\n  const startLatencyCompensator = () => {\n    if (latencyCompensator) {\n      latencyCompensator.stop();\n    }\n\n    latencyCompensatorEnabled = true;\n\n    latencyCompensator = new LatencyCompensator(playerRef.current);\n    latencyCompensator.setClockSkew(clockSkew);\n    latencyCompensator.enable();\n    setLocalStorage(LATENCY_COMPENSATION_ENABLED, true);\n\n    setLatencyCompensatorItemTitle('disable minimized latency');\n  };\n\n  const stopLatencyCompensator = () => {\n    if (latencyCompensator) {\n      latencyCompensator.disable();\n    }\n    latencyCompensator = null;\n    latencyCompensatorEnabled = false;\n    setLocalStorage(LATENCY_COMPENSATION_ENABLED, false);\n    setLatencyCompensatorItemTitle(\n      '<span style=\"font-size: 0.8em\">enable minimized latency (experimental)</span>',\n    );\n  };\n\n  const toggleLatencyCompensator = () => {\n    if (latencyCompensatorEnabled) {\n      stopLatencyCompensator();\n    } else {\n      startLatencyCompensator();\n    }\n  };\n\n  const setupLatencyCompensator = player => {\n    const tech = player.tech({ IWillNotUseThisInPlugins: true });\n\n    // VHS is required.\n    if (!tech || !tech.vhs) {\n      return;\n    }\n\n    const latencyCompensatorEnabledSaved = getLocalStorage(LATENCY_COMPENSATION_ENABLED);\n\n    if (latencyCompensatorEnabledSaved === 'true' && tech && tech.vhs) {\n      startLatencyCompensator();\n    } else {\n      stopLatencyCompensator();\n    }\n  };\n\n  const createSettings = async (player, videojs) => {\n    const videoQualities = await getVideoSettings();\n    const menuButton = createVideoSettingsMenuButton(\n      player,\n      videojs,\n      videoQualities,\n      toggleLatencyCompensator,\n    );\n    player.controlBar.addChild(\n      menuButton,\n      {},\n      // eslint-disable-next-line no-underscore-dangle\n      player.controlBar.children_.length - 2,\n    );\n    setupLatencyCompensator(player);\n  };\n\n  const setupAirplay = (player, videojs) => {\n    // eslint-disable-next-line no-prototype-builtins\n    if (window.hasOwnProperty('WebKitPlaybackTargetAvailabilityEvent')) {\n      const VJSButtonClass = videojs.getComponent('Button');\n\n      class ConcreteButtonClass extends VJSButtonClass {\n        constructor() {\n          super(player);\n        }\n\n        // eslint-disable-next-line class-methods-use-this\n        handleClick() {\n          try {\n            const videoElement = document.getElementsByTagName('video')[0];\n            (videoElement as any).webkitShowPlaybackTargetPicker();\n          } catch (e) {\n            console.error(e);\n          }\n        }\n      }\n\n      const ccbc = new ConcreteButtonClass();\n      const concreteButtonInstance = player.controlBar.addChild(ccbc);\n      concreteButtonInstance.addClass('vjs-airplay');\n    }\n  };\n\n  // Register keyboard shortcut for the space bar to toggle playback\n  useHotkeys('space', e => {\n    e.preventDefault();\n    togglePlayback();\n  });\n\n  // Register keyboard shortcut for f to toggle full screen\n  useHotkeys('f', toggleFullScreen, {\n    enableOnContentEditable: false,\n  });\n\n  // Register keyboard shortcut for the \"m\" key to toggle mute\n  useHotkeys('m', toggleMute, {\n    enableOnContentEditable: false,\n  });\n\n  useHotkeys('0', () => playerRef.current.volume(playerRef.current.volume() + 0.1), {\n    enableOnContentEditable: false,\n  });\n  useHotkeys('9', () => playerRef.current.volume(playerRef.current.volume() - 0.1), {\n    enableOnContentEditable: false,\n  });\n\n  const videoJsOptions = {\n    autoplay: false,\n    controls: true,\n    responsive: true,\n    fluid: false,\n    playsinline: true,\n    liveui: true,\n    preload: 'auto',\n    muted: initiallyMuted,\n    controlBar: {\n      progressControl: {\n        seekBar: false,\n      },\n    },\n    html5: {\n      vhs: {\n        // used to select the lowest bitrate playlist initially. This helps to decrease playback start time. This setting is false by default.\n        enableLowInitialPlaylist: true,\n        experimentalBufferBasedABR: true,\n        useNetworkInformationApi: true,\n        maxPlaylistRetries: 30,\n      },\n    },\n    liveTracker: {\n      trackingThreshold: 0,\n      liveTolerance: 15,\n    },\n    sources: [\n      {\n        src: source,\n        type: 'application/x-mpegURL',\n      },\n    ],\n  } satisfies VideoJsPlayerOptions;\n\n  const handlePlayerReady = (player, videojs) => {\n    playerRef.current = player;\n    setSavedVolume();\n    setupAirplay(player, videojs);\n\n    // You can handle player events here, for example:\n    player.on('waiting', () => {\n      console.debug('player is waiting');\n    });\n\n    player.on('dispose', () => {\n      console.debug('player will dispose');\n      ping.stop();\n    });\n\n    player.on('playing', () => {\n      console.debug('player is playing');\n      ping.start();\n      setVideoPlaying(true);\n    });\n\n    player.on('pause', () => {\n      console.debug('player is paused');\n      ping.stop();\n      setVideoPlaying(false);\n    });\n\n    player.on('ended', () => {\n      console.debug('player is ended');\n      ping.stop();\n      setVideoPlaying(false);\n    });\n\n    videojs.hookOnce();\n\n    player.on('volumechange', handleVolume);\n\n    playbackMetrics = new PlaybackMetrics(player, videojs);\n    playbackMetrics.setClockSkew(clockSkew);\n\n    createSettings(player, videojs);\n  };\n\n  useEffect(() => {\n    if (playbackMetrics) {\n      playbackMetrics.setClockSkew(clockSkew);\n    }\n  }, [clockSkew]);\n\n  useEffect(\n    () => () => {\n      stopLatencyCompensator();\n      playbackMetrics?.stop();\n    },\n    [],\n  );\n\n  return (\n    <div className={styles.container}>\n      {online && (\n        <div className={styles.player}>\n          <VideoJS options={videoJsOptions} onReady={handlePlayerReady} />\n        </div>\n      )}\n      <div className={styles.poster}>\n        {!videoPlaying && (\n          <VideoPoster online={online} initialSrc=\"/thumbnail.jpg\" src=\"/thumbnail.jpg\" />\n        )}\n      </div>\n    </div>\n  );\n};\nexport default OwncastPlayer;\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"OwncastPlayer_container__YfgRy\",\"player\":\"OwncastPlayer_player__R7XKJ\",\"poster\":\"OwncastPlayer_poster__8RqUC\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"player\":\"VideoJS_player__GT8FN\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"poster\":\"VideoPoster_poster__RDkSk\"};"],"names":["require","VideoJS","options","onReady","videoRef","React","playerRef","current","videoElement","player","videojs","console","debug","autoplay","src","sources","o","uri","match","cachebuster","Math","random","toString","substr","div","data-vjs-player","video","ref","className","styles","start","this","stop","timer","setInterval","fetch","e","error","ping","clearInterval","imgStyle","position","width","height","CrossfadeImage","objectFit","duration","spanStyle","useMemo","display","imgStyles","opacity","transition","key","setKey","useState","srcs","setSrcs","nextSrc","onLoadImg","span","style","map","singleSrc","index","img","alt","onLoad","undefined","defaultProps","VideoPoster","online","initialSrc","base","setSrc","setDuration","useEffect","Date","now","sendMetricsTimer","off","setClockSkew","skewMs","clockSkewMs","videoJSReady","tech","IWillNotUseThisInPlugins","supportsDetailedMetrics","on","name","setIsBuffering","incrementQualityVariantChanges","textTracks","addEventListener","handlePlaying","collectPlaybackMetricsTimer","collectPlaybackMetrics","handleEnded","handleBuffering","incrementErrorCount","handleNoLongerBuffering","handleError","count","errors","hasPerformedInitialVariantChange","qualityVariantChanges","isBuffering","bufferingDurationTimer","setTimeout","clearTimeout","trackSegmentDownloadTime","seconds","segmentDownloadTime","push","trackBandwidth","bps","bandwidthTracking","trackLatency","latency","latencyTracking","vhs","paused","networkState","bandwidth","systemBandwidth","segment","targetMedia","playlists","media","snapshotTime","currentTime","i","l","segments","length","end","getCurrentlyPlayingSegment","dateTimeObject","segmentTime","getTime","err","warn","async","errorCount","data","average","arr","reduce","p","c","averageDownloadDuration","roundedAverageDownloadDuration","round","averageBandwidth","roundedAverageBandwidth","averageLatency","downloadDuration","method","headers","body","JSON","stringify","constructor","bind","send","oldVjsXhrCallback","xhr","Vhs","args","cb","request","response","delta","qualities","latencyItemPressed","VjsMenuItem","getComponent","MenuItem","MenuButtonClass","lowLatencyItem","selectable","setAttribute","separator","createEl","tag","props","attributes","el","super","innerHTML","MenuButton","createItems","defaultAutoItem","label","items","item","newMenuItem","representations","forEach","rep","enabled","selected","supportsLatencyCompensator","menuButton","addClass","registerComponent","check","startupTime","seeking","inTimeout","totalBuffered","stats","buffered","timeout","buffer","currentPlaylistBandwidth","BANDWIDTH","bandwidthRatio","computedMinLatencyThreshold","max","targetLatencies","bufferedAtLatency","concat","minLatencyThreshold","sum","maxLatencyThreshold","min","currentLatency","abs","shouldJumpToLive","jumpAmount","seekPosition","info","availableBufferedTimeEnd","jump","proposedPlaybackRate","playbackRate","running","bufferingCounter","lastJumpOccurred","jumpingToLiveIgnoreBuffer","performedInitialLiveJump","setPlaybackRate","rate","log","enable","checkTimer","bufferingTimer","disable","timeoutTimer","endTimeout","wasPreviouslyPlaying","playing","liveTracker","seekToLiveEdge","handlePause","countBufferingEvent","PLAYER_VOLUME","LATENCY_COMPENSATION_ENABLED","ViewerPing","playbackMetrics","latencyCompensator","latencyCompensatorEnabled","OwncastPlayer","source","initiallyMuted","videoPlaying","setVideoPlaying","useRecoilState","isVideoPlayingAtom","clockSkew","useRecoilValue","clockSkewAtom","handleVolume","setLocalStorage","muted","volume","setLatencyCompensatorItemTitle","title","document","querySelector","startLatencyCompensator","LatencyCompensator","stopLatencyCompensator","toggleLatencyCompensator","createSettings","videoQualities","json","getVideoSettings","createVideoSettingsMenuButton","controlBar","addChild","children_","getLocalStorage","setupLatencyCompensator","setupAirplay","window","hasOwnProperty","VJSButtonClass","ConcreteButtonClass","handleClick","getElementsByTagName","webkitShowPlaybackTargetPicker","ccbc","useHotkeys","preventDefault","play","pause","isFullscreen","exitFullscreen","requestFullscreen","enableOnContentEditable","videoJsOptions","controls","responsive","fluid","playsinline","liveui","preload","progressControl","seekBar","html5","enableLowInitialPlaylist","experimentalBufferBasedABR","useNetworkInformationApi","maxPlaylistRetries","trackingThreshold","liveTolerance","type","setSavedVolume","hookOnce","PlaybackMetrics","module","exports"],"sourceRoot":""}
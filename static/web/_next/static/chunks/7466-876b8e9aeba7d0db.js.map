{"version":3,"file":"static/chunks/7466-876b8e9aeba7d0db.js","mappings":"+jBAYA,MARA,MACE,yBACE,MAAMA,QAAiBC,MAJT,eAMd,aADqBD,EAASE,S,WC0BlC,MApBA,MACE,4BAAmCC,GAEjC,aADuBC,EAAAA,EAAAA,IAAgB,GAA2BD,OAZpD,YAYqC,iBAA2B,OAAZA,IAIpE,0BAAiCE,GAC/B,MAAMC,EAAU,CACdC,OAAQ,OACRC,QAAS,CACP,eAAgB,oBAElBC,KAAMC,KAAKC,UAAU,CAAEC,YAAaP,KAItC,aADuBD,EAAAA,EAAAA,IAxBI,qBAwBmCE,K,WCrBnD,MAAMO,EA2BnBC,iBAAiBC,GACf,MAAMC,EAAM,IAAIC,IAAIF,GACpBC,EAAIE,SAAwC,WAA7BC,OAAOC,SAASF,SAAwB,OAAS,MAChEF,EAAIK,SAAW,MACfL,EAAIM,KAAgC,SAAzBH,OAAOC,SAASE,KAAkB,OAASH,OAAOC,SAASE,KACtEN,EAAIO,aAAaC,OAAO,cAAeC,KAAKtB,aAE5CuB,QAAQC,MAAM,iBAAkBX,EAAIY,YACpC,MAAMC,EAAK,IAAIC,UAAUd,EAAIY,YAC7BC,EAAGE,OAASN,KAAKO,OAAOC,KAAKR,MAC7BI,EAAGK,QAAUT,KAAKU,QAAQF,KAAKR,MAC/BI,EAAGO,UAAYX,KAAKY,UAAUJ,KAAKR,MAEnCA,KAAKa,UAAYT,EAGnBG,SACMP,KAAKc,yBACPC,aAAaf,KAAKc,yBAKtBJ,QAAQM,GAkFV,IAA+BC,IAjFL,iBAAmB,OAAFD,GAkFzCf,QAAQgB,MACN,2PAAiQ,OAANA,IAlF3PjB,KAAKa,UAAUK,QACVlB,KAAKmB,YACRnB,KAAKoB,oBAITA,oBACMpB,KAAKc,yBACPC,aAAaf,KAAKc,yBAEpBd,KAAKqB,SAAW,EAChBrB,KAAKc,wBAA0BQ,WAC7BtB,KAAKX,iBACL,IAAOkC,KAAKC,IAAIxB,KAAKqB,QAAS,MAIlCI,WACEzB,KAAKmB,YAAa,EAClBnB,KAAKa,UAAUK,QAQjBN,UAAUI,GAGR,MAAMU,EAAWV,EAAEW,KAAKC,MAAM,MAC9B,IAAIC,EAGJ,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAASK,OAAQD,IAAK,CACxC,IACED,EAAc5C,KAAK+C,MAAMN,EAASI,IAC9B9B,KAAKiC,eACPjC,KAAKiC,cAAcJ,GAErB,MAAOK,GAEP,YADAjC,QAAQgB,MAAMiB,EAAKA,EAAIP,MAIzB,IAAKE,EAAYM,KAEf,YADAlC,QAAQgB,MAAM,mBAAoBY,GAKpC,GAAIA,EAAYM,OAASC,EAAAA,EAAAA,KAEvB,YADApC,KAAKqC,YAMXC,c,IACS,EAA+B,EAAtC,OAAqB,QAAd,EAAAtC,KAAKa,iBAAL,eAAgB0B,eAA6B,QAAd,EAAAvC,KAAKa,iBAAL,eAAgB2B,MAIxDC,KAAKZ,GAEEA,EAAYM,MAASC,EAAAA,EAAYP,EAAYM,OAChDlC,QAAQyC,KAAK,mDAAoE,OAAjBb,EAAYM,KAAK,YAGnF,MAAMQ,EAAc1D,KAAKC,UAAU2C,GACnC7B,KAAKa,UAAU4B,KAAKE,GAItBN,WACE,MAAMO,EAAO,CAAET,KAAMC,EAAAA,EAAAA,MACrBpC,KAAKyC,KAAKG,GAjHZC,YAAYnE,EAAaoE,EAAMxD,G,KAN/B6B,YAAa,E,KAEbE,QAAU,IAKRrB,KAAKtB,YAAcA,EACnBsB,KAAK8C,KAAOA,EACZ9C,KAAKc,wBAA0B,KAC/Bd,KAAKmB,YAAa,EAElBnB,KAAKX,iBAAmBW,KAAKX,iBAAiBmB,KAAKR,MACnDA,KAAKyB,SAAWzB,KAAKyB,SAASjB,KAAKR,MAEnCA,KAAKX,iBAAiBC,I,kBC2BnB,G,SAAKyD,GAAAA,EACVC,QAAU,UADAD,EAEVE,OAAS,SAFCF,EAGVG,OAAS,SAHCH,EAIVI,QAAU,UAJAJ,EAKVK,cAAgB,iBALNL,EAMVM,KAAO,O,CANGN,IAAAA,EAAAA,KA+EZ,OApEEO,EAAAA,EAAAA,GAAc,CACZC,GAAI,WACJC,QAAS,UACTC,4BAA4B,EAC5BC,OAAQ,CACNC,QAAS,CACPC,KA/B+B,CACrCC,eAAe,EACfC,aAAa,EACbC,gBAAgB,EAChBC,YAAY,GA4BNC,GAAI,CACFC,eAAgB,CACdC,OAAQ,WAEVC,OAAQ,CACND,OAAQ,SAEVE,KAAM,CACJF,OAAQ,mBAIdG,MAAO,CACLd,QAAS,UACTE,OAAQ,CACNa,OAAQ,CACNX,KAAM,CAtDhBC,eAAe,EACfC,aAAa,EACbC,gBAAgB,EAChBC,YAAY,GAsDFC,GAAI,CACFO,QAAS,CACPL,OAAQ,aAIdM,QAAS,CACPb,KAAM,CAvEhBC,eAAe,EACfC,aAAa,EACbC,gBAAgB,EAChBC,YAAY,GAuEFC,GAAI,CACFS,OAAQ,CACNP,OAAQ,YAIdQ,QAAS,CACPV,GAAI,CACFS,OAAQ,CACNP,OAAQ,WAGZP,KAAM,CAjEhBC,eAAe,EACfC,aAAa,EACbC,gBAAgB,EAChBC,YAAY,GAiEFY,MAAO,CACL,IAAU,CACRT,OAAQ,eAMlBU,cAAe,CACb1C,KAAM,SAER2C,YAAa,CACX3C,KAAM,Y,sBClHd,MAhBO,SACL4C,EACAC,EACAC,GAEA,MAAM,KAAEC,GAASH,GACX,GAAExB,EAAE,YAAEpE,EAAW,aAAEgG,EAAY,OAAEC,EAAM,cAAEC,GAAkBH,EACjEF,EAAqBK,GAErBJ,EAAe,CACb1B,GAAIA,EAAGpD,WACPhB,cACAgG,eACAG,YAAaF,OAAAA,QAAAA,IAAAA,OAAAA,EAAAA,EAAQG,SAAS,gBCHlC,MARA,MACE,yBACE,MAAMhH,QAAiBC,MAJT,eAMd,aADqBD,EAASE,SCFlC,MAHO,SAA+BsG,EAAoBS,GACxDA,GAAgBC,GAAgB,IAAIA,EAAcV,MC0BpDW,EAAAA,GAAAA,4CAAuD,EAEvD,MACMC,EAAmB,cAEzB,IAAIC,EAIG,MAAMC,GAAoBC,EAAAA,EAAAA,IAAmB,CAClDC,IAAK,oBACLC,QC7BO,CACLzB,QAAQ,EACR0B,YAAa,EACbC,WAAY,IAAIC,QD8BPC,GAAwBN,EAAAA,EAAAA,IAAK,CACxCC,IAAK,oBACLC,QEEO,CACLK,KAAM,GACNC,QAAS,GACTC,eAAgB,GAChBC,KAAM,GACNC,KAAM,GACNC,QAAS,GACTC,MAAM,EACNC,iBAAkB,GAClBC,cAAe,GACfC,cAAc,EACdC,gBAAiB,GACjBC,aAAc,GACdC,oBAAqB,IAAIC,IACzBC,qBAAsB,EACtBC,WAAY,CACVC,SAAS,EACTC,QAAS,GACTC,cAAe,GAEjBC,cAAe,CACbC,QAAS,CACPJ,SAAS,EACTK,UAAW,KAGfC,eAAgB,CACdC,kBAAkB,MF1BXC,GAAkB/B,EAAAA,EAAAA,IAAa,CAC1CC,IAAK,kBACLC,QAAS,OAGE8B,GAAkBhC,EAAAA,EAAAA,IAAkB,CAC/CC,IAAK,kBACLC,QAAS,OAGE+B,GAAmBjC,EAAAA,EAAAA,IAAoB,CAClDC,IAAK,eACLC,QAAS,KAGEgC,GAAwBlC,EAAAA,EAAAA,IAAc,CACjDC,IAAK,wBACLC,SAAS,IAGEiC,GAAuBnC,EAAAA,EAAAA,IAAuB,CACzDC,IAAK,uBACLC,QAAS,KACTkC,4BAA4B,IAGjBC,GAAerC,EAAAA,EAAAA,IAAsB,CAChDC,IAAK,WACLC,QJvDO,CACLnC,eAAe,EACfC,aAAa,EACbC,gBAAgB,EAChBC,YAAY,KIsDHoE,GAAetC,EAAAA,EAAAA,IAA0B,CACpDC,IAAK,eACLC,aAASqC,IAGEC,GAAwBxC,EAAAA,EAAAA,IAAc,CACjDC,IAAK,2BACLC,SAAS,IAGEuC,GAAqBzC,EAAAA,EAAAA,IAAc,CAC9CC,IAAK,qBACLC,SAAS,IAGEwC,GAAsB1C,EAAAA,EAAAA,IAAuB,CACxDC,IAAK,sBACLC,QAAS,OAGEyC,GAAgB3C,EAAAA,EAAAA,IAAa,CACxCC,IAAK,gBACLC,QAAS,IAGE0C,GAAwB5C,EAAAA,EAAAA,IAAe,CAClDC,IAAK,oBACLC,QAAS,KAKE2C,GAAwBC,EAAAA,EAAAA,IAAS,CAC5C7C,IAAK,wBACL8C,IAAM,I,IAAA,IAAEA,GAAK,EACX,MAAMC,EAAyBD,EAAIV,GAC7BY,EAA6BF,EAAIP,GAEvC,OAD4BO,EAAIhB,IACViB,EAAMjF,eAAiBkF,KAIpCC,GAA0BJ,EAAAA,EAAAA,IAAS,CAC9C7C,IAAK,0BACL8C,IAAM,I,IAAA,IAAEA,GAAK,EACX,MAAMC,EAAyBD,EAAIV,GAEnC,OAD4BU,EAAIhB,IACViB,EAAMjF,iBAOnBoF,GAAmBL,EAAAA,EAAAA,IAAS,CACvC7C,IAAK,mBACL8C,IAAM,I,IAAA,IAAEA,GAAK,EACX,MAAMC,EAAyBD,EAAIV,GAC7Be,EAA0BL,EAAIN,GACpC,OAAOO,EAAM/E,gBAAkBmF,KAItBC,GAA8BP,EAAAA,EAAAA,IAAwB,CACjE7C,IAAK,8BACL8C,IAAM,I,IAAA,IAAEA,GAAK,EACX,MAAMnH,EAA0BmH,EAAId,GAC9BqB,EAAuBP,EAAIH,GACjC,OAAOhH,EAAS2H,QAAOtE,IAAYqE,EAAW7D,SAASR,EAAQxB,SAItD+F,EAAwB,KACnC,MAAOC,EAAUC,EAAcC,IAAmBC,EAAAA,EAAAA,GAAWC,IACtDC,EAAa3E,IAAkB4E,EAAAA,EAAAA,IAAe/B,GAC/C9C,GAAuB8E,EAAAA,EAAAA,IAA2B9B,IACjD+B,EAAcC,IAAmBH,EAAAA,EAAAA,IAA6BzD,IAC9D6D,EAAcC,IAAmBL,EAAAA,EAAAA,IAA6BhE,GAC/DsE,GAAeL,EAAAA,EAAAA,IAA0BrB,IACxC2B,EAAc5E,IAAmBqE,EAAAA,EAAAA,IAA8B9B,IAC/DrJ,EAAa2L,IAAkBR,EAAAA,EAAAA,IAAuBhC,GACvDyC,GAAcR,EAAAA,EAAAA,IAAmC3B,GACjDoC,GAA6BT,EAAAA,EAAAA,IAAoCtB,GACjEgC,GAAsBV,EAAAA,EAAAA,IAAoC7B,IACzDwC,EAAkBC,IAAuBb,EAAAA,EAAAA,IAAyBnB,IAClE,CAAEiC,IAAsBC,EAAAA,EAAAA,WAAS,IACjCC,EAAiBC,IAAsBF,EAAAA,EAAAA,WAAS,GAEvD,IAAIxK,EAEJ,MAAM2K,EAAsB,CAACC,EAAejG,KAC1CwF,EAA2B,CACzBS,QACAjG,aAGEkG,EAAaC,IAEjB1B,EAAa,CAAErH,KAAM+I,KA+BjBC,EAAqBC,UACzB,IACE,MAAMC,QAAeC,EAAAA,YACrBpB,EAAgBmB,GAChBV,GAAmB,GACnB,MAAM,WAAEzE,GAAemF,EAEjBE,EAAY,IAAIpF,KAAKD,GAAYsF,UAAYrF,KAAKsF,MACxDtB,EAAaoB,GAEbhB,EAA2B,MAC3B,MAAOtJ,GACPgK,EAAUlI,EAAcM,MACxB0H,EACE,iCACC,0EAEH9K,QAAQgB,MAAM,6CAAmD,OAANA,MAIzDyK,GAAyBN,MAAOO,IACpC,MAAMC,GAAmBC,EAAAA,EAAAA,IAAgBlG,GACzC,GAAIiG,EACFvB,EAAeuB,QAIjB,IACEX,EAAUlI,EAAcK,eACxB,MAAM7E,QAAiBuN,EAAAA,aAAyBH,IACxCjN,YAAaqN,EAAgB5M,YAAa6M,EAAc,aAAE7G,GAAiB5G,EACnF,IAAKwN,EACH,OAGF9G,EAAe,IACV2E,EACHzK,YAAa6M,EACb7G,iBAEFkF,EAAe0B,IACfE,EAAAA,EAAAA,IAAgBtG,EAAkBoG,GAClC,MAAO/K,GACPiK,EAAUlI,EAAcM,MACxBpD,QAAQgB,MAAM,0CAA4C,OAAFD,MAqBtDiB,GAAiB8C,IACrB,OAAQA,EAAQ5C,MACd,KAAKC,EAAAA,EAAAA,0BAlBP6J,EAAAA,EAAAA,IAAgBtG,EAAkB,IAClC0E,EAAe,MACfqB,KAkBI,MACF,KAAKtJ,EAAAA,EAAAA,oBACH8J,EACEnH,EACAC,EACAC,GAEFO,GAAgBC,GAAgB,IAAIA,EAAcV,KAClD,MACF,KAAK3C,EAAAA,EAAAA,KACHoD,GAAgBC,GAAgB,IAAIA,EAAcV,KAClD,MACF,KAAK3C,EAAAA,EAAAA,YACH+J,EAAsBpH,EAAsBS,GAC5C,MACF,KAAKpD,EAAAA,EAAAA,YAGL,KAAKA,EAAAA,EAAAA,OAGL,KAAKA,EAAAA,EAAAA,YACHoD,GAAgBC,GAAgB,IAAIA,EAAcV,KAClD,MACF,KAAK3C,EAAAA,EAAAA,kBAvC6B,CAAC2C,IACrC,MAAM,IAAEqH,EAAG,QAAEC,GAAYtH,EACzB,GAAIsH,EAAS,CACX,MAAMC,EAAa7B,EAAiBpB,QAAO9F,IAAO6I,EAAI7G,SAAShC,KAC/DmH,EAAoB4B,OACf,CACL,MAAMA,EAAa,IAAI7B,KAAqB2B,GAC5C1B,EAAoB4B,KAiClBC,CAA8BxH,GAC9B,MACF,QACE9E,QAAQgB,MAAM,gCAAiC8D,EAAQ5C,QAqG7D,OAvEAqK,EAAAA,EAAAA,YAAU,KACR,IACE,GAAI,OAAgBC,gBAAiB,CACnC,MAAMC,EAASzN,KAAK+C,MAAM,OAAgByK,iBAC1CzC,EAAgB0C,GAChB5B,GAAmB,IAErB,MAAO9J,GACPf,QAAQgB,MAAM,iCAAkCD,GAGlD,IACE,GAAI,OAAgB2L,gBAAiB,CACnC,MAAMtB,EAASpM,KAAK+C,MAAM,OAAgB2K,iBAC1CzC,EAAgBmB,GAChBV,GAAmB,IAErB,MAAO3J,GACPf,QAAQgB,MAAM,iCAAkCD,MAEjD,KAEHwL,EAAAA,EAAAA,YAAU,KAlLiB,IAACnB,IAmLPpB,EAlLfV,EAASqD,QAAQ,WACnB3B,EAAUlI,EAAcE,QAItBoI,EAAO9G,QAAUgF,EAASqD,QAAQ,SACpC3B,EAAUlI,EAAcG,QACdmI,EAAO9G,QAAWgF,EAASqD,QAAQ,kBAC7C3B,EAAUlI,EAAcI,WA2KzB,CAAC8G,KAEJuC,EAAAA,EAAAA,YAAU,MACHzC,EAAajD,cAAgBpI,GAAemM,GA5CjCO,WAChB,IACE,MAAM,mBAAEyB,GAAuB9C,EACzBzK,EAAOuN,GAAsBnN,OAAOC,SAASQ,WACnDC,EAAK,IAAIhB,EAAiBV,EAAa,MAAOY,GAC9Cc,EAAG6B,cAAgBA,GACnBuI,EAAoBpK,GACpB,MAAOa,GACPhB,QAAQgB,MAAM,uCAA6C,OAANA,MAqCrD6L,KAED,CAACjC,EAAiBnM,KAGrB8N,EAAAA,EAAAA,YAAU,QAEP,CAACpC,KAEJoC,EAAAA,EAAAA,YAAU,KApLiBpB,WACzB,IACE,MAAMsB,QAAeK,EAAAA,YACrB/C,EAAgB0C,GAChBnC,EAA2B,MAC3BO,GAAmB,GACnB,MAAO7J,GACP8J,EACE,iCACC,0EAEH9K,QAAQgB,MAAM,+CAAqD,OAANA,MA0K/D+L,GACAtB,KACAP,IAEA8B,cAAcrH,GACdA,EAA0BsH,aAAY,KACpC/B,MA9V8B,KAiWzB,KACL8B,cAAcrH,MAEf,KAEH4G,EAAAA,EAAAA,YAAU,KACH9N,GA/EgB0M,WACrB,IACE,MAAM1J,QAAiBoK,EAAAA,eAA2BpN,GAClD8G,GAAgBC,GAAgB,IAAIA,KAAiB/D,KACrD,MAAOT,GACPhB,QAAQgB,MAAM,4CAAkD,OAANA,MA8E5DkM,KACC,CAACzO,KAEJ8N,EAAAA,EAAAA,YAAU,KACR/C,EAAgB2D,cAAatE,IAC3B,MAAMuE,GAAWC,EAAAA,EAAAA,IAAUxE,EAAMlF,MAKjC0G,EAAY+C,QAEb,IAEI,O,sBGxZT,IAEO,E,yCAAKjL,GAAAA,EACVmL,KAAAA,OADUnL,EAEVoL,KAAAA,OAFUpL,EAGVqL,YAAAA,cAHUrL,EAIVsL,aAAAA,eAJUtL,EAKVuL,KAAAA,OALUvL,EAMVwL,OAAAA,SANUxL,EAOVyL,YAAAA,cAPUzL,EAQV0L,YAAAA,cARU1L,EASV2L,4BAAAA,8BATU3L,EAUV4L,0BAAAA,4BAVU5L,EAWV6L,4BAAAA,8BAXU7L,EAYV8L,oBAAAA,sBAZU9L,EAaV+L,oBAAAA,sBAbU/L,EAcVgM,yBAAAA,2BAdUhM,EAeViM,+BAAAA,iCAfUjM,EAgBVkM,kBAAoB,oB,CAhBVlM,IAAAA,EAAAA,M,8hCCDZ,MAAMmM,EAAiBC,EAAQC,IAAIC,2BAC7BC,EAAkBH,EAAQC,IAAIG,4BACvBC,EAAuBL,IAE9BM,EAAe,GAAwB,OAArBD,EAAqB,cAEhCE,EAAiB,KAGjBC,EAAS,GAAgB,OAAbF,EAAa,UASzBG,GANa,GAAgB,OAAbH,EAAa,cAGV,GAAgB,OAAbA,EAAa,aAGnB,GAAgB,OAAbA,EAAa,iBAGhCI,EAA2B,GAAgB,OAAbJ,EAAa,UAG3CK,EAAoB,GAAgB,OAAbL,EAAa,mBAGpCM,EAAwB,GAAgB,OAAbN,EAAa,WAGxCO,EAAoB,GAAgB,OAAbP,EAAa,gBAGpCQ,EAAiB,GAAgB,OAAbR,EAAa,uBAGjCS,EAAsB,GAAgB,OAAbT,EAAa,yBAGtCU,EAAa,GAAgB,OAAbV,EAAa,qBAG7BW,EAAmB,GAAgB,OAAbX,EAAa,4BAGnCY,EAAqB,GAAgB,OAAbZ,EAAa,2BAGrCa,EAAa,GAAgB,OAAbb,EAAa,yBAG7Bc,EAAiB,GAAgB,OAAbd,EAAa,iBAGjCe,EAAW,GAAgB,OAAbf,EAAa,QAG3BgB,EAAY,GAAgB,OAAbhB,EAAa,iBAG5BiB,EAAe,GAAgB,OAAbjB,EAAa,iBAG/BkB,EAA2B,oCAG3BC,EAAe,GAAgB,OAAbnB,EAAa,gBAG/BoB,EAAe,GAAgB,OAAbpB,EAAa,gBAG/BqB,EAAgB,GAAgB,OAAbrB,EAAa,gBAGhCsB,EAAsB,GAAgB,OAAbtB,EAAa,uBAGtCuB,EAAsB,GAAgB,OAAbvB,EAAa,uBAGtCwB,EAAW,GAAgB,OAAbxB,EAAa,YAG3ByB,EAAiB,GAAgB,OAAbzB,EAAa,mBAGjC0B,EAAiB,GAAgB,OAAb1B,EAAa,mBAGjC2B,EAAwB,GAAwB,OAArB5B,EAAqB,uBAMhD6B,GAHmB,GAAgB,OAAb5B,EAAa,uBAGT,GAAgB,OAAbA,EAAa,oBAG1C6B,EAAY,GAAgB,OAAb7B,EAAa,aAG5B8B,EAAoB,GAAgB,OAAb9B,EAAa,qBAGpC+B,EAAoB,GAAgB,OAAb/B,EAAa,qBAGpCgC,EAAwB,GAAgB,OAAbhC,EAAa,qBAGxCiC,EAAqB,GAAgB,OAAbjC,EAAa,sBAErCkC,EAA4B,GAAgB,OAAblC,EAAa,iBAG5CmC,EAAqB,GAAgB,OAAbnC,EAAa,qBAErCoC,EAAe,GAAgB,OAAbpC,EAAa,YAYrC1D,eAAe+F,EAAU5R,EAAaV,GAC3C,MAAM,KAAE8C,EAAI,OAAE7C,EAAS,MAAK,KAAEsS,GAAO,GAASvS,GAAW,GAGnDwS,EAA8B,CAClCvS,UAOF,GAJI6C,IACF0P,EAAerS,KAAOC,KAAKC,UAAUyC,IAGnCyP,GAAQ7C,GAAkBI,EAAiB,CAC7C,MAAM2C,EAAUC,KAAK,GAAqB5C,OAAlBJ,EAAe,KAAmB,OAAhBI,IAC1C0C,EAAetS,QAAU,CACvByS,cAAe,SAAiB,OAARF,IAE1BD,EAAeI,KAAO,OACtBJ,EAAeK,YAAc,UAG/B,IACE,MAAMnT,QAAiBC,MAAMe,EAAK8R,GAC5B5S,QAAaF,EAASE,OAE5B,IAAKF,EAASoT,GAAI,CAChB,MAAM5M,EAAUtG,EAAKsG,SAAW,0BAA0C,OAAhBxG,EAAS8M,QACnE,MAAM,IAAIuG,MAAM7M,GAElB,OAAOtG,EACP,MAAOwC,GAEP,OADAhB,QAAQgB,MAAMA,GACPA,GAMJmK,eAAezM,EAAgBY,EAAaV,GAMjD,OAAOsS,EAAU5R,EALJ,CACXT,OAAQ,MACRsS,MAAM,KACHvS,IAKAuM,eAAeyG,EAAkBtS,GACtC,IACE,MAAMhB,QAAiBC,MAAMe,EAAK,CAChCuS,eAAgB,cAChBC,SAAU,KAEZ,IAAKxT,EAASoT,GAAI,CAChB,MAAM5M,EAAU,yBAAyC,OAAhBxG,EAAS8M,QAClD,MAAM,IAAIuG,MAAM7M,GAGlB,aADmBxG,EAASE,OAE5B,MAAOwC,GACPhB,QAAQ+R,IAAI/Q,GAEd,MAAO,GAGFmK,eAAe6G,IACpB,OAAOJ,EA1EkB,gEA8E3B,MAAMK,EAAO,oBAyBN9G,eAAe+G,EAAwBC,GAE5C,IAAIC,SADwBJ,KACaK,SAMzC,MAJ0C,MAAtCD,EAAqBE,OAAO,EAAG,KACjCF,EAAuBA,EAAqBE,OAAO,IA7BvD,SAAkBC,EAAOC,GACvB,IAAKD,IAAUC,GAA2B,IAAjBD,EAAMzQ,QAAkC,IAAlB0Q,EAAO1Q,OAAc,OAAO,EAC3E,GAAIyQ,IAAUC,EAAQ,OAAO,EAC7B,GAAIP,EAAKQ,KAAKF,IAAUN,EAAKQ,KAAKD,GAAS,CACzC,MAAME,EAASH,EAAM5Q,MAAM,KAC3B,KAAO+Q,EAAO5Q,OAAS,GAAG4Q,EAAOC,KAAK,KACtC,MAAMC,EAASJ,EAAO7Q,MAAM,KAC5B,KAAOiR,EAAO9Q,OAAS,GAAG8Q,EAAOD,KAAK,KAEtC,IAAK,IAAI9Q,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,MAAMgR,EAAIC,SAASJ,EAAO7Q,GAAI,IACxBkR,EAAID,SAASF,EAAO/Q,GAAI,IAC9B,GAAIgR,IAAME,EAGV,OAAOF,EAAIE,EAEb,OAAO,EAET,OAAOR,GAASC,EAaXQ,CAASb,EAAgBC,GAIvB,KAHEA,I,sBC7IJ,SAASa,EAAqBC,GACnC,MAAMC,EAA4B,kBAAdD,EAAyB,IAAIhN,KAAKgN,GAAaA,EACnE,OAAQ,IAAIhN,KAASiN,GAAS,M,yDA6DzB,SAAS9F,EAAU1J,GACxB,OAAOyP,OAAOC,KAAK1P,GAAM2P,QAAO,CAACC,EAAKzN,KACpC,MAAM0N,EAAQ7P,EAAKmC,GAGnB,OAFAsN,OAAOK,OAAOF,EAAKC,GAEZD,IACN,M,uGCnKE,MAAMG,EAAqB,CAChC/U,SAAU,WACVgV,8BAA+B,mCAC/BC,eAAgB,oBAGX,SAAShI,EAAgB9F,GAC9B,IACE,OAAO+N,aAAaC,QAAQhO,GAC5B,MAAO/E,IACT,OAAO,KAGF,SAASiL,EAAgBlG,EAAK0N,GACnC,IAME,MALc,KAAVA,GAA0B,OAAVA,EAClBK,aAAaE,QAAQjO,EAAK0N,GAE1BK,aAAaG,WAAWlO,IAEnB,EACP,MAAO/E,IACT,OAAO","sources":["webpack://_N_E/./services/client-config-service.ts","webpack://_N_E/./services/chat-service.ts","webpack://_N_E/./services/websocket-service.ts","webpack://_N_E/./components/stores/application-state.ts","webpack://_N_E/./components/stores/eventhandlers/connected-client-info-handler.ts","webpack://_N_E/./services/status-service.ts","webpack://_N_E/./components/stores/eventhandlers/handleNameChangeEvent.tsx","webpack://_N_E/./components/stores/ClientConfigStore.tsx","webpack://_N_E/./interfaces/server-status.model.ts","webpack://_N_E/./interfaces/client-config.model.ts","webpack://_N_E/./interfaces/socket-events.ts","webpack://_N_E/./utils/apis.ts","webpack://_N_E/./utils/helpers.js","webpack://_N_E/./utils/localStorage.ts"],"sourcesContent":["import { ClientConfig } from '../interfaces/client-config.model';\n\nconst ENDPOINT = `/api/config`;\n\nclass ClientConfigService {\n  public static async getConfig(): Promise<ClientConfig> {\n    const response = await fetch(ENDPOINT);\n    const status = await response.json();\n    return status;\n  }\n}\n\nexport default ClientConfigService;\n","import { ChatMessage } from '../interfaces/chat-message.model';\nimport { getUnauthedData } from '../utils/apis';\n\nconst ENDPOINT = `/api/chat`;\nconst URL_CHAT_REGISTRATION = `/api/chat/register`;\n\ninterface UserRegistrationResponse {\n  id: string;\n  accessToken: string;\n  displayName: string;\n  displayColor: number;\n}\n\nclass ChatService {\n  public static async getChatHistory(accessToken: string): Promise<ChatMessage[]> {\n    const response = await getUnauthedData(`${ENDPOINT}?accessToken=${accessToken}`);\n    return response;\n  }\n\n  public static async registerUser(username: string): Promise<UserRegistrationResponse> {\n    const options = {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ displayName: username }),\n    };\n\n    const response = await getUnauthedData(URL_CHAT_REGISTRATION, options);\n    return response;\n  }\n}\n\nexport default ChatService;\n","import { MessageType, SocketEvent } from '../interfaces/socket-events';\n\nexport interface SocketMessage {\n  type: MessageType;\n  data: any;\n}\n\nexport default class WebsocketService {\n  websocket: WebSocket;\n\n  accessToken: string;\n\n  path: string;\n\n  websocketReconnectTimer: ReturnType<typeof setTimeout>;\n\n  isShutdown = false;\n\n  backOff = 1000;\n\n  handleMessage?: (message: SocketEvent) => void;\n\n  constructor(accessToken, path, host) {\n    this.accessToken = accessToken;\n    this.path = path;\n    this.websocketReconnectTimer = null;\n    this.isShutdown = false;\n\n    this.createAndConnect = this.createAndConnect.bind(this);\n    this.shutdown = this.shutdown.bind(this);\n\n    this.createAndConnect(host);\n  }\n\n  createAndConnect(host) {\n    const url = new URL(host);\n    url.protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n    url.pathname = '/ws';\n    url.port = window.location.port === '3000' ? '8080' : window.location.port;\n    url.searchParams.append('accessToken', this.accessToken);\n\n    console.debug('connecting to ', url.toString());\n    const ws = new WebSocket(url.toString());\n    ws.onopen = this.onOpen.bind(this);\n    ws.onerror = this.onError.bind(this);\n    ws.onmessage = this.onMessage.bind(this);\n\n    this.websocket = ws;\n  }\n\n  onOpen() {\n    if (this.websocketReconnectTimer) {\n      clearTimeout(this.websocketReconnectTimer);\n    }\n  }\n\n  // On ws error just close the socket and let it re-connect again for now.\n  onError(e) {\n    handleNetworkingError(`Socket error: ${e}`);\n    this.websocket.close();\n    if (!this.isShutdown) {\n      this.scheduleReconnect();\n    }\n  }\n\n  scheduleReconnect() {\n    if (this.websocketReconnectTimer) {\n      clearTimeout(this.websocketReconnectTimer);\n    }\n    this.backOff *= 2;\n    this.websocketReconnectTimer = setTimeout(\n      this.createAndConnect,\n      5000 + Math.min(this.backOff, 10_000),\n    );\n  }\n\n  shutdown() {\n    this.isShutdown = true;\n    this.websocket.close();\n  }\n\n  /*\n  onMessage is fired when an inbound object comes across the websocket.\n  If the message is of type `PING` we send a `PONG` back and do not\n  pass it along to listeners.\n  */\n  onMessage(e: SocketMessage) {\n    // Optimization where multiple events can be sent within a\n    // single websocket message. So split them if needed.\n    const messages = e.data.split('\\n');\n    let socketEvent: SocketEvent;\n\n    // eslint-disable-next-line no-plusplus\n    for (let i = 0; i < messages.length; i++) {\n      try {\n        socketEvent = JSON.parse(messages[i]);\n        if (this.handleMessage) {\n          this.handleMessage(socketEvent);\n        }\n      } catch (err) {\n        console.error(err, err.data);\n        return;\n      }\n\n      if (!socketEvent.type) {\n        console.error('No type provided', socketEvent);\n        return;\n      }\n\n      // Send PONGs\n      if (socketEvent.type === MessageType.PING) {\n        this.sendPong();\n        return;\n      }\n    }\n  }\n\n  isConnected(): boolean {\n    return this.websocket?.readyState === this.websocket?.OPEN;\n  }\n\n  // Outbound: Other components can pass an object to `send`.\n  send(socketEvent: any) {\n    // Sanity check that what we're sending is a valid type.\n    if (!socketEvent.type || !MessageType[socketEvent.type]) {\n      console.warn(`Outbound message: Unknown socket message type: \"${socketEvent.type}\" sent.`);\n    }\n\n    const messageJSON = JSON.stringify(socketEvent);\n    this.websocket.send(messageJSON);\n  }\n\n  // Reply to a PING as a keep alive.\n  sendPong() {\n    const pong = { type: MessageType.PONG };\n    this.send(pong);\n  }\n}\n\nfunction handleNetworkingError(error) {\n  console.error(\n    `Chat has been disconnected and is likely not working for you. It's possible you were removed from chat. If this is a server configuration issue, visit troubleshooting steps to resolve. https://owncast.online/docs/troubleshooting/#chat-is-disabled: ${error}`,\n  );\n}\n","/*\nThis is a finite state machine model that is used by xstate. https://xstate.js.org/\nYou send events to it and it changes state based on the pre-determined\nmodeling.\nThis allows for a clean and reliable way to model the current state of the\nweb application, and a single place to determine the flow of states.\n\nYou can paste this code into https://stately.ai/viz to see a visual state\nmap or install the VS Code plugin:\nhttps://marketplace.visualstudio.com/items?itemName=statelyai.stately-vscode\n*/\n\nimport { createMachine } from 'xstate';\n\nexport interface AppStateOptions {\n  chatAvailable: boolean;\n  chatLoading?: boolean;\n  videoAvailable: boolean;\n  appLoading?: boolean;\n}\n\nexport function makeEmptyAppState(): AppStateOptions {\n  return {\n    chatAvailable: false,\n    chatLoading: true,\n    videoAvailable: false,\n    appLoading: true,\n  };\n}\n\nconst OFFLINE_STATE: AppStateOptions = {\n  chatAvailable: false,\n  chatLoading: false,\n  videoAvailable: false,\n  appLoading: false,\n};\n\nconst ONLINE_STATE: AppStateOptions = {\n  chatAvailable: true,\n  chatLoading: false,\n  videoAvailable: true,\n  appLoading: false,\n};\n\nconst LOADING_STATE: AppStateOptions = {\n  chatAvailable: false,\n  chatLoading: false,\n  videoAvailable: false,\n  appLoading: true,\n};\n\nconst GOODBYE_STATE: AppStateOptions = {\n  chatAvailable: true,\n  chatLoading: false,\n  videoAvailable: false,\n  appLoading: false,\n};\n\nexport enum AppStateEvent {\n  Loading = 'LOADING', // Have not pulled configuration data from the server.\n  Loaded = 'LOADED', // Configuration data has been pulled from the server.\n  Online = 'ONLINE', // Stream is live\n  Offline = 'OFFLINE', // Stream is not live\n  NeedsRegister = 'NEEDS_REGISTER', // Needs to register a chat user\n  Fail = 'FAIL', // Error\n}\n\nconst appStateModel =\n  /** @xstate-layout N4IgpgJg5mDOIC5QEMAOqDKAXZWwDoAbAe2QgEsA7KAYgCUBRAcQEkMAVBxgEUVFWKxyWcsUp8QAD0QBGAGwz8ABgCscpUoDsAZgAcKgEwrtATgA0IAJ6zNS-CZMLtcuQBY9Jg5t0BfHxbRMHDwiUgpqGgA5BgZuDAB9RlYOLgkBIRExCWkEGRVFVXUtPUNjcytEAxNXfB0DbSNNORMG119-EEDsXAISMipaABkAeQBBbli0wWFRcSQpWQVlNQ0dfSNTC2tc+vwZVwMZWxNbA5kDAz8A9G6QvvDaADFRlkGpjNns2VcCleL1spbRDaA74FS6ORVfYHTSObRXTo3YIEABOYCg5FgeBRA3ozDYnB47xmWXmOQOKj22hUnl02iajjk2iBCCqdgO2n2VRcbQhCK6yPwaIxWLAOIiz1exMyc1A5KMVJpBjpDJczIqCG0enwXk0MiUENMjiUBjk-KRPSFYDIlnwYkIVDANGGj0egxY0WlnzJiF0TXwulU9LqWhMMl0LIM7ipmguIIObU85qClrRNrtADMMw7KE7hpF3Z75ukSbKFgg5Pp7PSQdTXBp9uVtlHtDG464E7okx0BanrRBbVBiMQIAAjSxOyRYy3IDPYgAU2g0y4AlDReyE0wP8EOR+OwF7SXLff7A8ZNCHYeGWedW3qlDIWkz61rLgjKCO4BIN70wgND2W8o3pyyjKrCdZ6q4sYqMmtyouimLYv+xbTDKXyakuyiuHI+QmCoJquCo2FyCyS52PURzqI+mgqIYpqwYKW62vajoAehsJyFS+paPhfoRhqUa6PgTIuLoRznComiEWaPYWpu-bMVmOYHihHxHuWRQ6pCJz0sqGgNMBBjCfohiEUoIJ0kyDF9umu5jhObE+rkqh2BCLS8XhYa6K4wGUuGtEviYZ5qNZ8k2o5x4IJJnGmlUOixoG5kGCy+G1JyXgHGJJhKByrihQQsBigAbmKjzIOQhAAK5ohF5YXJx+q2MYbieFB4KkW0yj6NBfr6vU3n5fglWFSiGblVVNWqaW6H5HY4bNFJbhKI4HV3k0rgnNlS6xm+1wpngtU5NeGoALQXDqbVBct+g5Qofh+EAA */\n  createMachine({\n    id: 'appState',\n    initial: 'loading',\n    predictableActionArguments: true,\n    states: {\n      loading: {\n        meta: LOADING_STATE,\n        on: {\n          NEEDS_REGISTER: {\n            target: 'loading',\n          },\n          LOADED: {\n            target: 'ready',\n          },\n          FAIL: {\n            target: 'serverFailure',\n          },\n        },\n      },\n      ready: {\n        initial: 'offline',\n        states: {\n          online: {\n            meta: {\n              ...ONLINE_STATE,\n            },\n            on: {\n              OFFLINE: {\n                target: 'goodbye',\n              },\n            },\n          },\n          offline: {\n            meta: {\n              ...OFFLINE_STATE,\n            },\n            on: {\n              ONLINE: {\n                target: 'online',\n              },\n            },\n          },\n          goodbye: {\n            on: {\n              ONLINE: {\n                target: 'online',\n              },\n            },\n            meta: {\n              ...GOODBYE_STATE,\n            },\n            after: {\n              '300000': {\n                target: 'offline',\n              },\n            },\n          },\n        },\n      },\n      serverFailure: {\n        type: 'final',\n      },\n      userfailure: {\n        type: 'final',\n      },\n    },\n  });\n\nexport default appStateModel;\n","import { ConnectedClientInfoEvent } from '../../../interfaces/socket-events';\n\nexport function handleConnectedClientInfoMessage(\n  message: ConnectedClientInfoEvent,\n  setChatAuthenticated: (boolean) => void,\n  setCurrentUser: (CurrentUser) => void,\n) {\n  const { user } = message;\n  const { id, displayName, displayColor, scopes, authenticated } = user;\n  setChatAuthenticated(authenticated);\n\n  setCurrentUser({\n    id: id.toString(),\n    displayName,\n    displayColor,\n    isModerator: scopes?.includes('MODERATOR'),\n  });\n}\nexport default handleConnectedClientInfoMessage;\n","import { ServerStatus } from '../interfaces/server-status.model';\n\nconst ENDPOINT = `/api/status`;\n\nclass ServerStatusService {\n  public static async getStatus(): Promise<ServerStatus> {\n    const response = await fetch(ENDPOINT);\n    const status = await response.json();\n    return status;\n  }\n}\n\nexport default ServerStatusService;\n","import { ChatEvent } from '../../../interfaces/socket-events';\n\nexport function handleNameChangeEvent(message: ChatEvent, setChatMessages) {\n  setChatMessages(currentState => [...currentState, message]);\n}\nexport default handleNameChangeEvent;\n","import { FC, useEffect, useState } from 'react';\nimport { atom, selector, useRecoilState, useSetRecoilState, RecoilEnv } from 'recoil';\nimport { useMachine } from '@xstate/react';\nimport { makeEmptyClientConfig, ClientConfig } from '../../interfaces/client-config.model';\nimport ClientConfigService from '../../services/client-config-service';\nimport ChatService from '../../services/chat-service';\nimport WebsocketService from '../../services/websocket-service';\nimport { ChatMessage } from '../../interfaces/chat-message.model';\nimport { CurrentUser } from '../../interfaces/current-user';\nimport { ServerStatus, makeEmptyServerStatus } from '../../interfaces/server-status.model';\nimport appStateModel, {\n  AppStateEvent,\n  AppStateOptions,\n  makeEmptyAppState,\n} from './application-state';\nimport { setLocalStorage, getLocalStorage } from '../../utils/localStorage';\nimport {\n  ConnectedClientInfoEvent,\n  MessageType,\n  ChatEvent,\n  MessageVisibilityEvent,\n  SocketEvent,\n} from '../../interfaces/socket-events';\nimport { mergeMeta } from '../../utils/helpers';\nimport handleConnectedClientInfoMessage from './eventhandlers/connected-client-info-handler';\nimport ServerStatusService from '../../services/status-service';\nimport handleNameChangeEvent from './eventhandlers/handleNameChangeEvent';\nimport { DisplayableError } from '../../types/displayable-error';\n\nRecoilEnv.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED = false;\n\nconst SERVER_STATUS_POLL_DURATION = 5000;\nconst ACCESS_TOKEN_KEY = 'accessToken';\n\nlet serverStatusRefreshPoll: ReturnType<typeof setInterval>;\n\n// Server status is what gets updated such as viewer count, durations,\n// stream title, online/offline state, etc.\nexport const serverStatusState = atom<ServerStatus>({\n  key: 'serverStatusState',\n  default: makeEmptyServerStatus(),\n});\n\n// The config that comes from the API.\nexport const clientConfigStateAtom = atom({\n  key: 'clientConfigState',\n  default: makeEmptyClientConfig(),\n});\n\nexport const accessTokenAtom = atom<string>({\n  key: 'accessTokenAtom',\n  default: null,\n});\n\nexport const currentUserAtom = atom<CurrentUser>({\n  key: 'currentUserAtom',\n  default: null,\n});\n\nexport const chatMessagesAtom = atom<ChatMessage[]>({\n  key: 'chatMessages',\n  default: [] as ChatMessage[],\n});\n\nexport const chatAuthenticatedAtom = atom<boolean>({\n  key: 'chatAuthenticatedAtom',\n  default: false,\n});\n\nexport const websocketServiceAtom = atom<WebsocketService>({\n  key: 'websocketServiceAtom',\n  default: null,\n  dangerouslyAllowMutability: true,\n});\n\nexport const appStateAtom = atom<AppStateOptions>({\n  key: 'appState',\n  default: makeEmptyAppState(),\n});\n\nexport const isMobileAtom = atom<boolean | undefined>({\n  key: 'isMobileAtom',\n  default: undefined,\n});\n\nexport const chatVisibleToggleAtom = atom<boolean>({\n  key: 'chatVisibilityToggleAtom',\n  default: true,\n});\n\nexport const isVideoPlayingAtom = atom<boolean>({\n  key: 'isVideoPlayingAtom',\n  default: false,\n});\n\nexport const fatalErrorStateAtom = atom<DisplayableError>({\n  key: 'fatalErrorStateAtom',\n  default: null,\n});\n\nexport const clockSkewAtom = atom<Number>({\n  key: 'clockSkewAtom',\n  default: 0.0,\n});\n\nexport const removedMessageIdsAtom = atom<string[]>({\n  key: 'removedMessageIds',\n  default: [],\n});\n\n// Chat is visible if the user wishes it to be visible AND the required\n// chat state is set.\nexport const isChatVisibleSelector = selector({\n  key: 'isChatVisibleSelector',\n  get: ({ get }) => {\n    const state: AppStateOptions = get(appStateAtom);\n    const userVisibleToggle: boolean = get(chatVisibleToggleAtom);\n    const accessToken: string = get(accessTokenAtom);\n    return accessToken && state.chatAvailable && userVisibleToggle;\n  },\n});\n\nexport const isChatAvailableSelector = selector({\n  key: 'isChatAvailableSelector',\n  get: ({ get }) => {\n    const state: AppStateOptions = get(appStateAtom);\n    const accessToken: string = get(accessTokenAtom);\n    return accessToken && state.chatAvailable;\n  },\n});\n\n// We display in an \"online/live\" state as long as video is actively playing.\n// Even during the time where technically the server has said it's no longer\n// live, however the last few seconds of video playback is still taking place.\nexport const isOnlineSelector = selector({\n  key: 'isOnlineSelector',\n  get: ({ get }) => {\n    const state: AppStateOptions = get(appStateAtom);\n    const isVideoPlaying: boolean = get(isVideoPlayingAtom);\n    return state.videoAvailable || isVideoPlaying;\n  },\n});\n\nexport const visibleChatMessagesSelector = selector<ChatMessage[]>({\n  key: 'visibleChatMessagesSelector',\n  get: ({ get }) => {\n    const messages: ChatMessage[] = get(chatMessagesAtom);\n    const removedIds: string[] = get(removedMessageIdsAtom);\n    return messages.filter(message => !removedIds.includes(message.id));\n  },\n});\n\nexport const ClientConfigStore: FC = () => {\n  const [appState, appStateSend, appStateService] = useMachine(appStateModel);\n  const [currentUser, setCurrentUser] = useRecoilState(currentUserAtom);\n  const setChatAuthenticated = useSetRecoilState<boolean>(chatAuthenticatedAtom);\n  const [clientConfig, setClientConfig] = useRecoilState<ClientConfig>(clientConfigStateAtom);\n  const [serverStatus, setServerStatus] = useRecoilState<ServerStatus>(serverStatusState);\n  const setClockSkew = useSetRecoilState<Number>(clockSkewAtom);\n  const [chatMessages, setChatMessages] = useRecoilState<ChatMessage[]>(chatMessagesAtom);\n  const [accessToken, setAccessToken] = useRecoilState<string>(accessTokenAtom);\n  const setAppState = useSetRecoilState<AppStateOptions>(appStateAtom);\n  const setGlobalFatalErrorMessage = useSetRecoilState<DisplayableError>(fatalErrorStateAtom);\n  const setWebsocketService = useSetRecoilState<WebsocketService>(websocketServiceAtom);\n  const [hiddenMessageIds, setHiddenMessageIds] = useRecoilState<string[]>(removedMessageIdsAtom);\n  const [, setHasLoadedStatus] = useState(false);\n  const [hasLoadedConfig, setHasLoadedConfig] = useState(false);\n\n  let ws: WebsocketService;\n\n  const setGlobalFatalError = (title: string, message: string) => {\n    setGlobalFatalErrorMessage({\n      title,\n      message,\n    });\n  };\n  const sendEvent = (event: string) => {\n    // console.debug('---- sending event:', event);\n    appStateSend({ type: event });\n  };\n\n  const handleStatusChange = (status: ServerStatus) => {\n    if (appState.matches('loading')) {\n      sendEvent(AppStateEvent.Loaded);\n      return;\n    }\n\n    if (status.online && appState.matches('ready')) {\n      sendEvent(AppStateEvent.Online);\n    } else if (!status.online && !appState.matches('ready.offline')) {\n      sendEvent(AppStateEvent.Offline);\n    }\n  };\n\n  const updateClientConfig = async () => {\n    try {\n      const config = await ClientConfigService.getConfig();\n      setClientConfig(config);\n      setGlobalFatalErrorMessage(null);\n      setHasLoadedConfig(true);\n    } catch (error) {\n      setGlobalFatalError(\n        'Unable to reach Owncast server',\n        `Owncast cannot launch. Please make sure the Owncast server is running.`,\n      );\n      console.error(`ClientConfigService -> getConfig() ERROR: \\n${error}`);\n    }\n  };\n\n  const updateServerStatus = async () => {\n    try {\n      const status = await ServerStatusService.getStatus();\n      setServerStatus(status);\n      setHasLoadedStatus(true);\n      const { serverTime } = status;\n\n      const clockSkew = new Date(serverTime).getTime() - Date.now();\n      setClockSkew(clockSkew);\n\n      setGlobalFatalErrorMessage(null);\n    } catch (error) {\n      sendEvent(AppStateEvent.Fail);\n      setGlobalFatalError(\n        'Unable to reach Owncast server',\n        `Owncast cannot launch. Please make sure the Owncast server is running.`,\n      );\n      console.error(`serverStatusState -> getStatus() ERROR: \\n${error}`);\n    }\n  };\n\n  const handleUserRegistration = async (optionalDisplayName?: string) => {\n    const savedAccessToken = getLocalStorage(ACCESS_TOKEN_KEY);\n    if (savedAccessToken) {\n      setAccessToken(savedAccessToken);\n      return;\n    }\n\n    try {\n      sendEvent(AppStateEvent.NeedsRegister);\n      const response = await ChatService.registerUser(optionalDisplayName);\n      const { accessToken: newAccessToken, displayName: newDisplayName, displayColor } = response;\n      if (!newAccessToken) {\n        return;\n      }\n\n      setCurrentUser({\n        ...currentUser,\n        displayName: newDisplayName,\n        displayColor,\n      });\n      setAccessToken(newAccessToken);\n      setLocalStorage(ACCESS_TOKEN_KEY, newAccessToken);\n    } catch (e) {\n      sendEvent(AppStateEvent.Fail);\n      console.error(`ChatService -> registerUser() ERROR: \\n${e}`);\n    }\n  };\n\n  const resetAndReAuth = () => {\n    setLocalStorage(ACCESS_TOKEN_KEY, '');\n    setAccessToken(null);\n    handleUserRegistration();\n  };\n\n  const handleMessageVisibilityChange = (message: MessageVisibilityEvent) => {\n    const { ids, visible } = message;\n    if (visible) {\n      const updatedIds = hiddenMessageIds.filter(id => !ids.includes(id));\n      setHiddenMessageIds(updatedIds);\n    } else {\n      const updatedIds = [...hiddenMessageIds, ...ids];\n      setHiddenMessageIds(updatedIds);\n    }\n  };\n\n  const handleMessage = (message: SocketEvent) => {\n    switch (message.type) {\n      case MessageType.ERROR_NEEDS_REGISTRATION:\n        resetAndReAuth();\n        break;\n      case MessageType.CONNECTED_USER_INFO:\n        handleConnectedClientInfoMessage(\n          message as ConnectedClientInfoEvent,\n          setChatAuthenticated,\n          setCurrentUser,\n        );\n        setChatMessages(currentState => [...currentState, message as ChatEvent]);\n        break;\n      case MessageType.CHAT:\n        setChatMessages(currentState => [...currentState, message as ChatEvent]);\n        break;\n      case MessageType.NAME_CHANGE:\n        handleNameChangeEvent(message as ChatEvent, setChatMessages);\n        break;\n      case MessageType.USER_JOINED:\n        setChatMessages(currentState => [...currentState, message as ChatEvent]);\n        break;\n      case MessageType.SYSTEM:\n        setChatMessages(currentState => [...currentState, message as ChatEvent]);\n        break;\n      case MessageType.CHAT_ACTION:\n        setChatMessages(currentState => [...currentState, message as ChatEvent]);\n        break;\n      case MessageType.VISIBILITY_UPDATE:\n        handleMessageVisibilityChange(message as MessageVisibilityEvent);\n        break;\n      default:\n        console.error('Unknown socket message type: ', message.type);\n    }\n  };\n\n  const getChatHistory = async () => {\n    try {\n      const messages = await ChatService.getChatHistory(accessToken);\n      setChatMessages(currentState => [...currentState, ...messages]);\n    } catch (error) {\n      console.error(`ChatService -> getChatHistory() ERROR: \\n${error}`);\n    }\n  };\n\n  const startChat = async () => {\n    try {\n      const { socketHostOverride } = clientConfig;\n      const host = socketHostOverride || window.location.toString();\n      ws = new WebsocketService(accessToken, '/ws', host);\n      ws.handleMessage = handleMessage;\n      setWebsocketService(ws);\n    } catch (error) {\n      console.error(`ChatService -> startChat() ERROR: \\n${error}`);\n    }\n  };\n\n  const handleChatNotification = () => {};\n\n  // Read the config and status on initial load from a JSON string that lives\n  // in window. This is placed there server-side and allows for fast initial\n  // load times because we don't have to wait for the API calls to complete.\n  useEffect(() => {\n    try {\n      if ((window as any).configHydration) {\n        const config = JSON.parse((window as any).configHydration);\n        setClientConfig(config);\n        setHasLoadedConfig(true);\n      }\n    } catch (e) {\n      console.error('Error parsing config hydration', e);\n    }\n\n    try {\n      if ((window as any).statusHydration) {\n        const status = JSON.parse((window as any).statusHydration);\n        setServerStatus(status);\n        setHasLoadedStatus(true);\n      }\n    } catch (e) {\n      console.error('error parsing status hydration', e);\n    }\n  }, []);\n\n  useEffect(() => {\n    handleStatusChange(serverStatus);\n  }, [serverStatus]);\n\n  useEffect(() => {\n    if (!clientConfig.chatDisabled && accessToken && hasLoadedConfig) {\n      startChat();\n    }\n  }, [hasLoadedConfig, accessToken]);\n\n  // Notify about chat activity when backgrounded.\n  useEffect(() => {\n    handleChatNotification();\n  }, [chatMessages]);\n\n  useEffect(() => {\n    updateClientConfig();\n    handleUserRegistration();\n    updateServerStatus();\n\n    clearInterval(serverStatusRefreshPoll);\n    serverStatusRefreshPoll = setInterval(() => {\n      updateServerStatus();\n    }, SERVER_STATUS_POLL_DURATION);\n\n    return () => {\n      clearInterval(serverStatusRefreshPoll);\n    };\n  }, []);\n\n  useEffect(() => {\n    if (!accessToken) {\n      return;\n    }\n\n    getChatHistory();\n  }, [accessToken]);\n\n  useEffect(() => {\n    appStateService.onTransition(state => {\n      const metadata = mergeMeta(state.meta) as AppStateOptions;\n\n      // console.debug('--- APP STATE: ', state.value);\n      // console.debug('--- APP META: ', metadata);\n\n      setAppState(metadata);\n    });\n  }, []);\n\n  return null;\n};\n","export interface ServerStatus {\n  online: boolean;\n  viewerCount: number;\n  lastConnectTime?: Date;\n  lastDisconnectTime?: Date;\n  versionNumber?: string;\n  streamTitle?: string;\n  serverTime: Date;\n}\n\nexport function makeEmptyServerStatus(): ServerStatus {\n  return {\n    online: false,\n    viewerCount: 0,\n    serverTime: new Date(),\n  };\n}\n","export interface ClientConfig {\n  name: string;\n  title?: string;\n  summary: string;\n  offlineMessage?: string;\n  logo: string;\n  tags: string[];\n  version: string;\n  nsfw: boolean;\n  extraPageContent: string;\n  socialHandles: SocialHandle[];\n  chatDisabled: boolean;\n  externalActions: any[];\n  customStyles: string;\n  appearanceVariables: Map<string, string>;\n  maxSocketPayloadSize: number;\n  federation: Federation;\n  notifications: Notifications;\n  authentication: Authentication;\n  socketHostOverride?: string;\n}\n\ninterface Authentication {\n  indieAuthEnabled: boolean;\n}\n\ninterface Federation {\n  enabled: boolean;\n  account: string;\n  followerCount: number;\n}\n\ninterface Notifications {\n  browser: Browser;\n}\n\ninterface Browser {\n  enabled: boolean;\n  publicKey: string;\n}\n\ninterface SocialHandle {\n  platform: string;\n  url: string;\n  icon: string;\n}\n\nexport function makeEmptyClientConfig(): ClientConfig {\n  return {\n    name: '',\n    summary: '',\n    offlineMessage: '',\n    logo: '',\n    tags: [],\n    version: '',\n    nsfw: false,\n    extraPageContent: '',\n    socialHandles: [],\n    chatDisabled: false,\n    externalActions: [],\n    customStyles: '',\n    appearanceVariables: new Map(),\n    maxSocketPayloadSize: 0,\n    federation: {\n      enabled: false,\n      account: '',\n      followerCount: 0,\n    },\n    notifications: {\n      browser: {\n        enabled: false,\n        publicKey: '',\n      },\n    },\n    authentication: {\n      indieAuthEnabled: false,\n    },\n  };\n}\n","import { User } from './user.model';\n\nexport enum MessageType {\n  CHAT = 'CHAT',\n  PING = 'PING',\n  NAME_CHANGE = 'NAME_CHANGE',\n  COLOR_CHANGE = 'COLOR_CHANGE',\n  PONG = 'PONG',\n  SYSTEM = 'SYSTEM',\n  USER_JOINED = 'USER_JOINED',\n  CHAT_ACTION = 'CHAT_ACTION',\n  FEDIVERSE_ENGAGEMENT_FOLLOW = 'FEDIVERSE_ENGAGEMENT_FOLLOW',\n  FEDIVERSE_ENGAGEMENT_LIKE = 'FEDIVERSE_ENGAGEMENT_LIKE',\n  FEDIVERSE_ENGAGEMENT_REPOST = 'FEDIVERSE_ENGAGEMENT_REPOST',\n  CONNECTED_USER_INFO = 'CONNECTED_USER_INFO',\n  ERROR_USER_DISABLED = 'ERROR_USER_DISABLED',\n  ERROR_NEEDS_REGISTRATION = 'ERROR_NEEDS_REGISTRATION',\n  ERROR_MAX_CONNECTIONS_EXCEEDED = 'ERROR_MAX_CONNECTIONS_EXCEEDED',\n  VISIBILITY_UPDATE = 'VISIBILITY-UPDATE',\n}\n\nexport interface SocketEvent {\n  id: string;\n  timestamp: Date;\n  type: MessageType;\n}\n\nexport interface ConnectedClientInfoEvent extends SocketEvent {\n  user: User;\n}\nexport interface ChatEvent extends SocketEvent {\n  user: User;\n  body: string;\n}\n\nexport interface NameChangeEvent extends SocketEvent {\n  user: User;\n  oldName: string;\n}\n\nexport interface MessageVisibilityEvent extends SocketEvent {\n  visible: boolean;\n  ids: string[];\n}\n","/* eslint-disable prefer-destructuring */\nconst ADMIN_USERNAME = process.env.NEXT_PUBLIC_ADMIN_USERNAME;\nconst ADMIN_STREAMKEY = process.env.NEXT_PUBLIC_ADMIN_STREAMKEY;\nexport const NEXT_PUBLIC_API_HOST = process.env.NEXT_PUBLIC_API_HOST;\n\nconst API_LOCATION = `${NEXT_PUBLIC_API_HOST}api/admin/`;\n\nexport const FETCH_INTERVAL = 15000;\n\n// Current inbound broadcaster info\nexport const STATUS = `${API_LOCATION}status`;\n\n// Disconnect inbound stream\nexport const DISCONNECT = `${API_LOCATION}disconnect`;\n\n// Change the current streaming key in memory\nexport const STREAMKEY_CHANGE = `${API_LOCATION}changekey`;\n\n// Current server config\nexport const SERVER_CONFIG = `${API_LOCATION}serverconfig`;\n\n// Base url to update config settings\nexport const SERVER_CONFIG_UPDATE_URL = `${API_LOCATION}config`;\n\n// Get viewer count over time\nexport const VIEWERS_OVER_TIME = `${API_LOCATION}viewersOverTime`;\n\n// Get active viewer details\nexport const ACTIVE_VIEWER_DETAILS = `${API_LOCATION}viewers`;\n\n// Get currently connected chat clients\nexport const CONNECTED_CLIENTS = `${API_LOCATION}chat/clients`;\n\n// Get list of disabled/blocked chat users\nexport const DISABLED_USERS = `${API_LOCATION}chat/users/disabled`;\n\n// Disable/enable a single user\nexport const USER_ENABLED_TOGGLE = `${API_LOCATION}chat/users/setenabled`;\n\n// Get banned IP addresses\nexport const BANNED_IPS = `${API_LOCATION}chat/users/ipbans`;\n\n// Remove IP ban\nexport const BANNED_IP_REMOVE = `${API_LOCATION}chat/users/ipbans/remove`;\n\n// Disable/enable a single user\nexport const USER_SET_MODERATOR = `${API_LOCATION}chat/users/setmoderator`;\n\n// Get list of moderators\nexport const MODERATORS = `${API_LOCATION}chat/users/moderators`;\n\n// Get hardware stats\nexport const HARDWARE_STATS = `${API_LOCATION}hardwarestats`;\n\n// Get all logs\nexport const LOGS_ALL = `${API_LOCATION}logs`;\n\n// Get warnings + errors\nexport const LOGS_WARN = `${API_LOCATION}logs/warnings`;\n\n// Get chat history\nexport const CHAT_HISTORY = `${API_LOCATION}chat/messages`;\n\n// Get chat history\nexport const UPDATE_CHAT_MESSGAE_VIZ = `/api/admin/chat/messagevisibility`;\n\n// Upload a new custom emoji\nexport const UPLOAD_EMOJI = `${API_LOCATION}emoji/upload`;\n\n// Delete a custom emoji\nexport const DELETE_EMOJI = `${API_LOCATION}emoji/delete`;\n\n// Get all access tokens\nexport const ACCESS_TOKENS = `${API_LOCATION}accesstokens`;\n\n// Delete a single access token\nexport const DELETE_ACCESS_TOKEN = `${API_LOCATION}accesstokens/delete`;\n\n// Create a new access token\nexport const CREATE_ACCESS_TOKEN = `${API_LOCATION}accesstokens/create`;\n\n// Get webhooks\nexport const WEBHOOKS = `${API_LOCATION}webhooks`;\n\n// Delete a single webhook\nexport const DELETE_WEBHOOK = `${API_LOCATION}webhooks/delete`;\n\n// Create a single webhook\nexport const CREATE_WEBHOOK = `${API_LOCATION}webhooks/create`;\n\n// hard coded social icons list\nexport const SOCIAL_PLATFORMS_LIST = `${NEXT_PUBLIC_API_HOST}api/socialplatforms`;\n\n// set external action links\nexport const EXTERNAL_ACTIONS = `${API_LOCATION}api/externalactions`;\n\n// send a message to the fediverse\nexport const FEDERATION_MESSAGE_SEND = `${API_LOCATION}federation/send`;\n\n// Get followers\nexport const FOLLOWERS = `${API_LOCATION}followers`;\n\n// Get followers pending approval\nexport const FOLLOWERS_PENDING = `${API_LOCATION}followers/pending`;\n\n// Get followers who were blocked or rejected\nexport const FOLLOWERS_BLOCKED = `${API_LOCATION}followers/blocked`;\n\n// Approve, reject a follow request\nexport const SET_FOLLOWER_APPROVAL = `${API_LOCATION}followers/approve`;\n\n// List of inbound federated actions that took place.\nexport const FEDERATION_ACTIONS = `${API_LOCATION}federation/actions`;\n\nexport const API_STREAM_HEALTH_METRICS = `${API_LOCATION}metrics/video`;\n\n// Save an array of stream keys\nexport const UPDATE_STREAM_KEYS = `${API_LOCATION}config/streamkeys`;\n\nexport const API_YP_RESET = `${API_LOCATION}yp/reset`;\n\nexport const TEMP_UPDATER_API = LOGS_ALL;\n\nconst GITHUB_RELEASE_URL = 'https://api.github.com/repos/owncast/owncast/releases/latest';\n\ninterface FetchOptions {\n  data?: any;\n  method?: string;\n  auth?: boolean;\n}\n\nexport async function fetchData(url: string, options?: FetchOptions) {\n  const { data, method = 'GET', auth = true } = options || {};\n\n  // eslint-disable-next-line no-undef\n  const requestOptions: RequestInit = {\n    method,\n  };\n\n  if (data) {\n    requestOptions.body = JSON.stringify(data);\n  }\n\n  if (auth && ADMIN_USERNAME && ADMIN_STREAMKEY) {\n    const encoded = btoa(`${ADMIN_USERNAME}:${ADMIN_STREAMKEY}`);\n    requestOptions.headers = {\n      Authorization: `Basic ${encoded}`,\n    };\n    requestOptions.mode = 'cors';\n    requestOptions.credentials = 'include';\n  }\n\n  try {\n    const response = await fetch(url, requestOptions);\n    const json = await response.json();\n\n    if (!response.ok) {\n      const message = json.message || `An error has occurred: ${response.status}`;\n      throw new Error(message);\n    }\n    return json;\n  } catch (error) {\n    console.error(error);\n    return error;\n    // console.log(error)\n    // throw new Error(error)\n  }\n}\n\nexport async function getUnauthedData(url: string, options?: FetchOptions) {\n  const opts = {\n    method: 'GET',\n    auth: false,\n    ...options,\n  };\n  return fetchData(url, opts);\n}\n\nexport async function fetchExternalData(url: string) {\n  try {\n    const response = await fetch(url, {\n      referrerPolicy: 'no-referrer', // Send no referrer header for privacy reasons.\n      referrer: '',\n    });\n    if (!response.ok) {\n      const message = `An error has occured: ${response.status}`;\n      throw new Error(message);\n    }\n    const json = await response.json();\n    return json;\n  } catch (error) {\n    console.log(error);\n  }\n  return {};\n}\n\nexport async function getGithubRelease() {\n  return fetchExternalData(GITHUB_RELEASE_URL);\n}\n\n// Stolen from https://gist.github.com/prenagha/98bbb03e27163bc2f5e4\nconst VPAT = /^\\d+(\\.\\d+){0,2}$/;\nfunction upToDate(local, remote) {\n  if (!local || !remote || local.length === 0 || remote.length === 0) return false;\n  if (local === remote) return true;\n  if (VPAT.test(local) && VPAT.test(remote)) {\n    const lparts = local.split('.');\n    while (lparts.length < 3) lparts.push('0');\n    const rparts = remote.split('.');\n    while (rparts.length < 3) rparts.push('0');\n    // eslint-disable-next-line no-plusplus\n    for (let i = 0; i < 3; i++) {\n      const l = parseInt(lparts[i], 10);\n      const r = parseInt(rparts[i], 10);\n      if (l === r)\n        // eslint-disable-next-line no-continue\n        continue;\n      return l > r;\n    }\n    return true;\n  }\n  return local >= remote;\n}\n\n// Make a request to the server status API and the Github releases API\n// and return a release if it's newer than the server version.\nexport async function upgradeVersionAvailable(currentVersion) {\n  const recentRelease = await getGithubRelease();\n  let recentReleaseVersion = recentRelease.tag_name;\n\n  if (recentReleaseVersion.substr(0, 1) === 'v') {\n    recentReleaseVersion = recentReleaseVersion.substr(1);\n  }\n\n  if (!upToDate(currentVersion, recentReleaseVersion)) {\n    return recentReleaseVersion;\n  }\n\n  return null;\n}\n","// convert newlines to <br>s\nexport function addNewlines(str) {\n  return str.replace(/(?:\\r\\n|\\r|\\n)/g, '<br />');\n}\n\nexport function pluralize(string, count) {\n  if (count === 1) {\n    return string;\n  }\n  return `${string}s`;\n}\n\n// Trying to determine if browser is mobile/tablet.\n// Source: https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent\nexport function hasTouchScreen() {\n  let hasTouch = false;\n  if ('maxTouchPoints' in navigator) {\n    hasTouch = navigator.maxTouchPoints > 0;\n  } else if ('msMaxTouchPoints' in navigator) {\n    hasTouch = navigator.msMaxTouchPoints > 0;\n  } else {\n    const mQ = window.matchMedia && matchMedia('(pointer:coarse)');\n    if (mQ && mQ.media === '(pointer:coarse)') {\n      hasTouch = !!mQ.matches;\n    } else if ('orientation' in window) {\n      hasTouch = true; // deprecated, but good fallback\n    } else {\n      // Only as a last resort, fall back to user agent sniffing\n      hasTouch = navigator.userAgentData.mobile;\n    }\n  }\n  return hasTouch;\n}\n\nexport function padLeft(text, pad, size) {\n  return String(pad.repeat(size) + text).slice(-size);\n}\n\nexport function parseSecondsToDurationString(seconds = 0) {\n  const finiteSeconds = Number.isFinite(+seconds) ? Math.abs(seconds) : 0;\n\n  const days = Math.floor(finiteSeconds / 86400);\n  const daysString = days > 0 ? `${days} day${days > 1 ? 's' : ''} ` : '';\n\n  const hours = Math.floor((finiteSeconds / 3600) % 24);\n  const hoursString = hours || days ? padLeft(`${hours}:`, '0', 3) : '';\n\n  const mins = Math.floor((finiteSeconds / 60) % 60);\n  const minString = padLeft(`${mins}:`, '0', 3);\n\n  const secs = Math.floor(finiteSeconds % 60);\n  const secsString = padLeft(`${secs}`, '0', 2);\n\n  return daysString + hoursString + minString + secsString;\n}\n\nexport function setVHvar() {\n  const vh = window.innerHeight * 0.01;\n  // Then we set the value in the --vh custom property to the root of the document\n  document.documentElement.style.setProperty('--vh', `${vh}px`);\n}\n\nexport function doesObjectSupportFunction(object, functionName) {\n  return typeof object[functionName] === 'function';\n}\n\n// return a string of css classes\nexport function classNames(json) {\n  const classes = [];\n\n  Object.entries(json).map(item => {\n    const [key, value] = item;\n    if (value) {\n      classes.push(key);\n    }\n    return null;\n  });\n  return classes.join(' ');\n}\n\n// taken from\n// https://medium.com/@TCAS3/debounce-deep-dive-javascript-es6-e6f8d983b7a1\nexport function debounce(fn, time) {\n  let timeout;\n\n  return function () {\n    // eslint-disable-next-line prefer-rest-params\n    const functionCall = () => fn.apply(this, arguments);\n\n    clearTimeout(timeout);\n    timeout = setTimeout(functionCall, time);\n  };\n}\n\nexport function getDiffInDaysFromNow(timestamp) {\n  const time = typeof timestamp === 'string' ? new Date(timestamp) : timestamp;\n  return (new Date() - time) / (24 * 3600 * 1000);\n}\n\n// \"Last live today at [time]\" or \"last live [date]\"\nexport function makeLastOnlineString(timestamp) {\n  if (!timestamp) {\n    return '';\n  }\n  let string = '';\n  const time = new Date(timestamp);\n  const comparisonDate = new Date(time).setHours(0, 0, 0, 0);\n\n  if (comparisonDate === new Date().setHours(0, 0, 0, 0)) {\n    const atTime = time.toLocaleTimeString([], {\n      hour: '2-digit',\n      minute: '2-digit',\n    });\n    string = `Today ${atTime}`;\n  } else {\n    string = time.toLocaleDateString();\n  }\n\n  return `Last live: ${string}`;\n}\n\n// Routing & Tabs\nexport const ROUTE_RECORDINGS = 'recordings';\nexport const ROUTE_SCHEDULE = 'schedule';\n// looks for `/recording|schedule/id` pattern to determine what to display from the tab view\nexport function checkUrlPathForDisplay() {\n  const pathTest = [ROUTE_RECORDINGS, ROUTE_SCHEDULE];\n  const pathParts = window.location.pathname.split('/');\n\n  if (pathParts.length >= 2) {\n    const part = pathParts[1].toLowerCase();\n    if (pathTest.includes(part)) {\n      return {\n        section: part,\n        sectionId: pathParts[2] || '',\n      };\n    }\n  }\n  return null;\n}\n\nexport function paginateArray(items, page, perPage) {\n  const offset = perPage * (page - 1);\n  const totalPages = Math.ceil(items.length / perPage);\n  const paginatedItems = items.slice(offset, perPage * page);\n\n  return {\n    previousPage: page - 1 ? page - 1 : null,\n    nextPage: totalPages > page ? page + 1 : null,\n    total: items.length,\n    totalPages,\n    items: paginatedItems,\n  };\n}\n\n// Take a nested object of state metadata and merge it into\n// a single flattened node.\nexport function mergeMeta(meta) {\n  return Object.keys(meta).reduce((acc, key) => {\n    const value = meta[key];\n    Object.assign(acc, value);\n\n    return acc;\n  }, {});\n}\n","export const LOCAL_STORAGE_KEYS = {\n  username: 'username',\n  hasDisplayedNotificationModal: 'HAS_DISPLAYED_NOTIFICATION_MODAL',\n  userVisitCount: 'USER_VISIT_COUNT',\n};\n\nexport function getLocalStorage(key) {\n  try {\n    return localStorage.getItem(key);\n  } catch (e) {}\n  return null;\n}\n\nexport function setLocalStorage(key, value) {\n  try {\n    if (value !== '' && value !== null) {\n      localStorage.setItem(key, value);\n    } else {\n      localStorage.removeItem(key);\n    }\n    return true;\n  } catch (e) {}\n  return false;\n}\n\nexport function clearLocalStorage(key) {\n  localStorage.removeItem(key);\n}\n\n// jump down to the max height of a div, with a slight delay\nexport function jumpToBottom(element, behavior) {\n  if (!element) return;\n\n  if (!behavior) {\n    behavior = document.visibilityState === 'visible' ? 'smooth' : 'instant';\n  }\n\n  setTimeout(\n    () => {\n      element.scrollTo({\n        top: element.scrollHeight,\n        left: 0,\n        behavior,\n      });\n    },\n    50,\n    element,\n  );\n}\n"],"names":["response","fetch","json","accessToken","getUnauthedData","username","options","method","headers","body","JSON","stringify","displayName","WebsocketService","createAndConnect","host","url","URL","protocol","window","location","pathname","port","searchParams","append","this","console","debug","toString","ws","WebSocket","onopen","onOpen","bind","onerror","onError","onmessage","onMessage","websocket","websocketReconnectTimer","clearTimeout","e","error","close","isShutdown","scheduleReconnect","backOff","setTimeout","Math","min","shutdown","messages","data","split","socketEvent","i","length","parse","handleMessage","err","type","MessageType","sendPong","isConnected","readyState","OPEN","send","warn","messageJSON","pong","constructor","path","AppStateEvent","Loading","Loaded","Online","Offline","NeedsRegister","Fail","createMachine","id","initial","predictableActionArguments","states","loading","meta","chatAvailable","chatLoading","videoAvailable","appLoading","on","NEEDS_REGISTER","target","LOADED","FAIL","ready","online","OFFLINE","offline","ONLINE","goodbye","after","serverFailure","userfailure","message","setChatAuthenticated","setCurrentUser","user","displayColor","scopes","authenticated","isModerator","includes","setChatMessages","currentState","RecoilEnv","ACCESS_TOKEN_KEY","serverStatusRefreshPoll","serverStatusState","atom","key","default","viewerCount","serverTime","Date","clientConfigStateAtom","name","summary","offlineMessage","logo","tags","version","nsfw","extraPageContent","socialHandles","chatDisabled","externalActions","customStyles","appearanceVariables","Map","maxSocketPayloadSize","federation","enabled","account","followerCount","notifications","browser","publicKey","authentication","indieAuthEnabled","accessTokenAtom","currentUserAtom","chatMessagesAtom","chatAuthenticatedAtom","websocketServiceAtom","dangerouslyAllowMutability","appStateAtom","isMobileAtom","undefined","chatVisibleToggleAtom","isVideoPlayingAtom","fatalErrorStateAtom","clockSkewAtom","removedMessageIdsAtom","isChatVisibleSelector","selector","get","state","userVisibleToggle","isChatAvailableSelector","isOnlineSelector","isVideoPlaying","visibleChatMessagesSelector","removedIds","filter","ClientConfigStore","appState","appStateSend","appStateService","useMachine","appStateModel","currentUser","useRecoilState","useSetRecoilState","clientConfig","setClientConfig","serverStatus","setServerStatus","setClockSkew","chatMessages","setAccessToken","setAppState","setGlobalFatalErrorMessage","setWebsocketService","hiddenMessageIds","setHiddenMessageIds","setHasLoadedStatus","useState","hasLoadedConfig","setHasLoadedConfig","setGlobalFatalError","title","sendEvent","event","updateServerStatus","async","status","ServerStatusService","clockSkew","getTime","now","handleUserRegistration","optionalDisplayName","savedAccessToken","getLocalStorage","ChatService","newAccessToken","newDisplayName","setLocalStorage","handleConnectedClientInfoMessage","handleNameChangeEvent","ids","visible","updatedIds","handleMessageVisibilityChange","useEffect","configHydration","config","statusHydration","matches","socketHostOverride","startChat","ClientConfigService","updateClientConfig","clearInterval","setInterval","getChatHistory","onTransition","metadata","mergeMeta","CHAT","PING","NAME_CHANGE","COLOR_CHANGE","PONG","SYSTEM","USER_JOINED","CHAT_ACTION","FEDIVERSE_ENGAGEMENT_FOLLOW","FEDIVERSE_ENGAGEMENT_LIKE","FEDIVERSE_ENGAGEMENT_REPOST","CONNECTED_USER_INFO","ERROR_USER_DISABLED","ERROR_NEEDS_REGISTRATION","ERROR_MAX_CONNECTIONS_EXCEEDED","VISIBILITY_UPDATE","ADMIN_USERNAME","process","env","NEXT_PUBLIC_ADMIN_USERNAME","ADMIN_STREAMKEY","NEXT_PUBLIC_ADMIN_STREAMKEY","NEXT_PUBLIC_API_HOST","API_LOCATION","FETCH_INTERVAL","STATUS","SERVER_CONFIG","SERVER_CONFIG_UPDATE_URL","VIEWERS_OVER_TIME","ACTIVE_VIEWER_DETAILS","CONNECTED_CLIENTS","DISABLED_USERS","USER_ENABLED_TOGGLE","BANNED_IPS","BANNED_IP_REMOVE","USER_SET_MODERATOR","MODERATORS","HARDWARE_STATS","LOGS_ALL","LOGS_WARN","CHAT_HISTORY","UPDATE_CHAT_MESSGAE_VIZ","UPLOAD_EMOJI","DELETE_EMOJI","ACCESS_TOKENS","DELETE_ACCESS_TOKEN","CREATE_ACCESS_TOKEN","WEBHOOKS","DELETE_WEBHOOK","CREATE_WEBHOOK","SOCIAL_PLATFORMS_LIST","FEDERATION_MESSAGE_SEND","FOLLOWERS","FOLLOWERS_PENDING","FOLLOWERS_BLOCKED","SET_FOLLOWER_APPROVAL","FEDERATION_ACTIONS","API_STREAM_HEALTH_METRICS","UPDATE_STREAM_KEYS","API_YP_RESET","fetchData","auth","requestOptions","encoded","btoa","Authorization","mode","credentials","ok","Error","fetchExternalData","referrerPolicy","referrer","log","getGithubRelease","VPAT","upgradeVersionAvailable","currentVersion","recentReleaseVersion","tag_name","substr","local","remote","test","lparts","push","rparts","l","parseInt","r","upToDate","getDiffInDaysFromNow","timestamp","time","Object","keys","reduce","acc","value","assign","LOCAL_STORAGE_KEYS","hasDisplayedNotificationModal","userVisitCount","localStorage","getItem","setItem","removeItem"],"sourceRoot":""}